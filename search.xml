<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[实验2 基本图元光栅化]]></title>
    <url>%2F2018%2F10%2F14%2FCG-Prj2-Primitive%2F</url>
    <content type="text"><![CDATA[1．实验目的： 理解基本图形元素光栅化的基本原理； 掌握基本图形元素光栅化方法，如中点方法，Bresenham方法； 利用OpenGL实现基本图形元素的光栅化算法。 2．实验内容：（1） 阅读学习所给的直线光栅化的DDA算法示范代码，将其彻底弄懂，根据实验思考题找出其中的错误；同时能在计算机上编译运行，输出正确结果，指出错误并截图保存为图1至word实验文档（30分钟）； （2） 在示范程序的基础上，根据程序所留接口，增加中点线算法，并给出若干条测试直线实例，，截图保存为图2至word实验文档（30分钟）； （3） 为示范程序增加中点圆绘制算法，同时增加键盘按键控制（数字按键3），并给出若干个测试圆的实例，截图保存为图3至word实验文档（30分钟）； （4） 整理图1-3，并增加程序代码合并到一个word文档，将其命名为“序号-姓名-Prj2.doc”，电子版提交至雨课堂，A4打印稿下一次课前或实验课前提交。 3．实验原理：示范代码原理参见教材直线光栅化一节中的DDA算法。下面介绍下OpenGL画线的一些基础知识和glutReshapeFunc()函数。 （1）数学上的直线没有宽度，但OpenGL的直线则是有宽度的。同时，OpenGL的直线必须是有限长度，而不是像数学概念那样是无限的。可以认为，OpenGL的“直线”概念与数学上的“线段”接近，它可以由两个端点来确定。这里的线由一系列顶点顺次连结而成，有闭合和不闭合两种。 前面的实验已经知道如何绘“点”，那么OpenGL是如何知道拿这些顶点来做什么呢？是一个一个的画出来，还是连成线？或者构成一个多边形？或是做其它事情呢？为了解决这一问题，OpenGL要求：指定顶点的命令必须包含在glBegin函数之后，glEnd函数之前（否则指定的顶点将被忽略），并由glBegin来指明如何使用这些点。 例如：1234567glBegin(GL_POINTS); glVertex2f(0.0f, 0.0f); glVertex2f(0.5f, 0.0f);glEnd(); 则这两个点将分别被画出来。如果将GL_POINTS替换成GL_LINES，则两个点将被认为是直线的两个端点，OpenGL将会画出一条直线。还可以指定更多的顶点，然后画出更复杂的图形。另一方面，glBegin支持的方式除了GL_POINTS和GL_LINES，还有GL_LINE_STRIP，GL_LINE_LOOP，GL_TRIANGLES，GL_TRIANGLE_STRIP，GL_TRIANGLE_FAN等，每种方式的大致效果如图A.2所示： 图A.2 OpenGL几何图元类型 （2）首次打开窗口、移动窗口和改变窗口大小时，窗口系统都将发送一个事件，以通知程序员。如果使用的是GLUT，通知将自动完成，并调用向glutReshapeFunc()注册的函数。该函数必须完成下列工作： 重新建立用作新渲染画布的矩形区域； 定义绘制物体时使用的坐标系。 如：12345678910111213void Reshape(int w, int h)&#123;glViewport(0, 0, (GLsizei) w, (GLsizei) h);glMatrixMode(GL_PROJECTION);glLoadIdentity();gluOrtho2D(0.0, (GLdouble) w, 0.0, (GLdouble) h);&#125; 在GLUT内部，将给该函数传递两个参数：窗口被移动或修改大小后的宽度和高度，单位为像素。glViewport()调整像素矩形，用于绘制整个窗口。接下来三个函数调整绘图坐标系，使左下角位置为（0， 0），右上角为（w, h）。 （3） 键盘输入 当你按下一个键后，GLUT提供了两个函数为这个键盘消息注册回调。第一个是glutKeyboardFunc，用来处理普通按键，如字母，数字，和其他可以用ASCII代码表示的键；另一个是glutSpecialFunc，用来处理特殊按键，如$F_i$，方向键，Home，End键等。 glutKeyboardFunc函数原型如下：void glutKeyboardFunc(void(*func)(unsigned char key,int x,int y));参数：func: 处理普通按键消息的函数的名称。如果传递NULL，则表示GLUT忽略普通按键消息。这个作为glutKeyboardFunc函数参数的函数需要有三个形参：第一个表示按下的键的ASCII码，其余两个提供了当键按下时当前的鼠标位置。鼠标位置是相对于当前客户窗口的左上角而言的。 glutSpecialFunc函数请参考https://blog.csdn.net/xie_zi/article/details/1911891。 4．实验代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;GL/glut.h&gt;int flag = 0;void LineDDA(int x0,int y0,int x1,int y1/*,int color*/)&#123; int x, dy, dx, y; float m; dx=x1-x0; dy=y1-y0; m=dy/dx; y=y0; glColor3f (1.0f, 1.0f, 0.0f); glPointSize(1); for(x=x0;x&lt;=x1; x++) &#123; glBegin (GL_POINTS); glVertex2i (x, (int)(y+0.5)); glEnd (); y+=m; &#125; &#125;void LineMidPoint(int x0, int y0, int x1, int y1)&#123; //请在这里填写你的代码&#125;void myDisplay(void)&#123; glClear(GL_COLOR_BUFFER_BIT); glColor3f (1.0f, 0.0f, 0.0f); glRectf(25.0, 25.0, 75.0, 75.0); glPointSize(5); glBegin (GL_POINTS); glColor3f (0.0f, 1.0f, 0.0f); glVertex2f (0.0f, 0.0f); glEnd (); glBegin (GL_LINES); glColor3f (1.0f, 0.0f, 0.0f); glVertex2f (100.0f, 0.0f); glColor3f (0.0f, 1.0f, 0.0f); glVertex2f (180.0f, 240.0f); glEnd (); if(flag == 1) LineDDA(0, 0, 200, 300); //if (flag == 2) //LineMidPoint(...); glFlush();&#125;void Init()&#123; glClearColor(0.0, 0.0, 0.0, 0.0); glShadeModel(GL_FLAT);&#125;void Reshape(int w, int h)&#123; glViewport(0, 0, (GLsizei) w, (GLsizei) h); glMatrixMode(GL_PROJECTION); glLoadIdentity(); gluOrtho2D(0.0, (GLdouble) w, 0.0, (GLdouble) h);&#125;void keyboard(unsigned char key, int x, int y)&#123; switch (key) &#123; case &apos;1&apos;://DDA Line flag = 1; break; case &apos;2&apos;: // MidPoint Line //请在这里填写你的代码 break; default: break; &#125; glutPostRedisplay();//重画&#125;int main(int argc, char *argv[])&#123; glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE); glutInitWindowPosition(100, 100); glutInitWindowSize(400, 400); glutCreateWindow(&quot;Hello World!&quot;); Init(); glutDisplayFunc(myDisplay); glutReshapeFunc(Reshape); glutKeyboardFunc(keyboard); glutMainLoop(); return 0;&#125; 注： glShadeModel选择平坦或光滑渐变模式。GL_SMOOTH为缺省值，为光滑渐变模式，GL_FLAT为平坦渐变模式。 5．实验思考示范代码有个小错误，能否指出并改正？请将结果写入实验报告。]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实验4 个人大学数据可视化]]></title>
    <url>%2F2018%2F10%2F09%2FPrj4_UniversityStudyVisualization%2F</url>
    <content type="text"><![CDATA[一. 实验目的和要求1. 复习前述可视化知识和方法。2. 综合应用前面所学可视化知识和方法，对大学学习与生活有关数据进行可视化。二. 实验内容1. 将自己9门专业主干课程成绩可视化：高级语言程序设计、离散数学、数据结构、计算机组成原理、操作系统原理、计算机网络、数据库系统原理、编译原理、软件工程；2. 将自己的前三年综合积分及其名次可视化；3. 总结自己的专业技能与其它技能，并根据技能水平对其可视化。技能水平建议分为一般，熟练，精通，专家四种：4. 回顾上大学至今自已去过的地方，将其可视化；5. 根据以上4方面的信息，制作一个简单的个人简历,打印稿下次上课前提交，电子稿提交到雨课堂。三. 实验报告实验报告中的实验过程请根据实验内容结合自己的具体实验过程填写； 实验结果： 简单的个人简历，可以手绘，可以文字描述，也可以将图缩小打印贴上； 实验分析部分可以对整个实验过程进行回顾与总结，可以从以下一些问题角度进行分析： 实验难度与自身水平相比如何？ 通过实验有无发现自己有待提高的知识或能力吗？ 碰到什么问题？如何解决？ 本次实验有何收获或心得？简单介绍下。]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《计算机图形学基础（OpenGL版）》勘误表]]></title>
    <url>%2F2018%2F10%2F08%2FCGBook_Error%2F</url>
    <content type="text"><![CDATA[页码 行或位置 原内容 更正为 备注 38 9 (1MB) (128KB) 41 16 $$k=\Delta x/\Delta y$$ $$k=\Delta y/\Delta x$$ 43 9 $$d \leq 0$$ $$d \geq 0$$ 46 6 $$ s-t = s \frac{\Delta x}{\Delta y}(x_i+1)+2b+2y_i-1$$ $$ s-t = s \frac{\Delta x}{\Delta y}(x_i+1)+2b -2y_i-1$$ 46 倒数第4行 $$-1\leq1\leq0$$ $$0\leq k\leq 1$$ 47 26 int curx = x1; int curx = x1 + 1; 48 12 $$b=x_0-x_1$$ $$b=x_1-x_0$$ 51 19 令$T$点的坐标为$（x_i, y_i)$ 令$P$点的坐标为$（x_i, y_i)$ 52 倒数第3行 Cirpot(x0, y0, x, y) Cirpot(x0, y0, x, y, color) 53 9 Cirpot(x0, y0, x, y) Cirpot(x0, y0, x, y, color) 57 7 FloodFill FloodFill4 57 13-16 FloodFill4(…, newcolor) FloodFill4(…, newcolor, boundaryColor) 58-59 58页倒数第2行~59页第11行 见教材 从点P向任意方向发出一条射线，若该射线与多边形交点的个数为奇数，则P位于多边形内；若为偶数，则P位于多边形外部。当射线与多边形边界点的交点是多边形顶点时（该交点称为奇点，如图3-13的$P_3$，$P_4$，$P_5$和$P_6$情况），如果把每一个奇点简单地计为一个交点，则交点个数为偶数时P点可能在内部，如图3-13中的$P_4$情况。但若将每一个奇点都简单地计为两个交点，同样会导致错误的结果，如图3-13中的$P_3$和$P_5$情况。因此，必须按不同情况区别对待。一般来说，多边形的顶点可分为两类：极值点和非极值点。如果顶点相邻的两边在射线的同侧时，则称该顶点为极值点（如图3-13中的$Q_0$和$Q_1$）；否则称该顶点为非极值点（如图3-13中的$Q_2$）。为了保证射线法判别结果的正确性，奇点交点的计数可以根据上述分类来采用不同的方式。当奇点是多边形的极值点时，交点按照两个交点计算，否则，按一个交点计算，如图3.13所示。 59 图3-13 见教材 60 图3.16 65 倒数第4行 图3.22 图3.23 65 倒数第3行 $y_i+m/2$ $y_i-int(y_i)+m/2$ 73 6 $$ y’=rsin(\phi+\theta)=rcos \phi sin \theta - rsin \phi cos \theta $$ $$ y’=rsin(\phi+\theta)=rcos \phi sin \theta + rsin \phi cos \theta $$ 75 8 相对于y轴的反射 相对于x轴的反射 117 2 $$T=R(\theta)T(-x_0, -y_0) =\begin{bmatrix} cos\theta &amp; \mathbf{sin\theta} &amp; 0 \ \mathbf{-sin\theta} &amp; cos\theta &amp; 0 \ 0 &amp; 0 &amp; 1 \ \end{bmatrix} \begin{bmatrix} 1 &amp; 0 &amp; -x_0 \0 &amp; 1 &amp; -y_0 \0 &amp; 0 &amp; 1 \end{bmatrix}$$ $$T=R(\theta)T(-x_0, -y_0) = \begin{bmatrix} cos\theta &amp; -sin\theta &amp; 0 \sin\theta &amp; cos\theta &amp; 0 \ 0 &amp; 0 &amp; 1 \end{bmatrix} \begin{bmatrix} 1 &amp; 0 &amp; -x_0 \0 &amp; 1 &amp; -y_0 \0 &amp; 0 &amp; 1 \end{bmatrix} $$ 122 15 $$t_1^{‘’}=(x_R-x_1)/dx$$ $$t_1^{‘’}=(y_B-y_1)/dy$$ 130 24 glLoadIdentity() 应移至void display(void)中的第1个glColor3f(0.0,0.0,1.0)后 参考5.5 Opengl编程实例－红蓝三角形 131 1 131 图5.17后 无 增加思考内容：“思考：教材中原代码中根据所给三角形顶点坐标，三角形应为一个正角形，为何显示时不是正角形呢？同时，在旋转后的三角形也发生了变形，请分析原因，并给出修改建议。提示：请从”glViewport()”函数入手。” 135 (6.2) $$u=\frac{V \times n}{\mid N \mid} = (u_x, u_y, u_z)$$ $$u=\frac{V \times n}{\mid V \times n \mid} = (u_x, u_y, u_z)$$ 151 (6.29) $$ \begin{bmatrix}x_p \ y_p \ 0 \ 1 \end{bmatrix} =\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\ 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix} \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\ 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; \frac{1}{d} &amp; \mathbf{ 1} \end{bmatrix} \begin{bmatrix} x_s \ y_s \ z_s \ 1 \end{bmatrix} = \begin{bmatrix} x_s \ y_s \ 0 \ \mathbf{1+ \frac{z_s}{d}} \end{bmatrix}$$ $$ \begin{bmatrix} x_p \ y_p \ 0 \ 1 \end{bmatrix} =\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\ 0 &amp; 1 &amp; 0 &amp; 0 \0 &amp; 0 &amp; 0 &amp; 0 \0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix} \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\ 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; \frac{1}{d} &amp; \mathbf{0}\end{bmatrix} \begin{bmatrix} x_s \ y_s \ z_s \ 1 \end{bmatrix} = \begin{bmatrix} x_s \ y_s \ 0 \ \mathbf{ \frac{z_s}{d} } \end{bmatrix}$$ 151 (6.31) $$ \begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\ 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; r &amp; \mathbf{1}\end{bmatrix} $$ $$ \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\ 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; r &amp; \mathbf{0}\end{bmatrix} $$ 151 (6.33) $$ \begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\ 0 &amp; 1 &amp; 0 &amp; 0 \0 &amp; 0 &amp; 1 &amp; 0 \ p &amp; 0 &amp; 0 &amp; \mathbf{1}\end{bmatrix} $$ $$ \begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 &amp; 0 \ p &amp; 0 &amp; 0 &amp; \mathbf{0 }\end{bmatrix} $$ 151 (6.34) $$ \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\ 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; q &amp; 0 &amp; \mathbf{1}\end{bmatrix} $$ $$ \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\ 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; q &amp; 0 &amp; \mathbf{0}\end{bmatrix} $$ 152 (6.35) 152 (6.35) 152 12 线性关系 非线性关系 152 (6.37) $$ a=\frac{-(z_{far}+z_{near})z_{near}}{z_{far}-z_{near}}$$ $$ a=\frac{z_{far}+z_{near}}{z_{near}(z_{far}-z_{near})}$$ 224 2 对于右手坐标系 对于OpenGL所采用的左手坐标系 烟台大学韩明峰指正 图8.17 8 深度缓冲器所有单元均置为最小 z值 深度缓冲器所有单元均置为最大 z值 为保持与图8.17一致而修改，原内容也没错，下同 11 若z &gt; ZB(x, y)，则ZB(x, y)=z 若z &lt; ZB(x, y)，则ZB(x, y)=z 20 ZB(x,y)单元置为最小值 ZB(x,y)单元置为最大值 26 if(z(x,y) &gt; ZB(x,y)) if(z(x,y) &lt; ZB(x,y)) 附录B 模拟试题及答案 页码 位置 原内容 更正 备注 337 图B.1 340 模2试题，一.单选题，第6题 $$T= \left[ \begin{matrix} 2 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 \ 1 &amp; 1 &amp; 1 \end{matrix} \right] $$ $$P^{‘}= PT =\left[ \begin{matrix} x &amp; y &amp; 1 \end{matrix} \right] \left[ \begin{matrix} 2 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 \ 1 &amp; 1 &amp; 1 \end{matrix} \right] $$ 345 模3试题，一.单选题，第1题B选项 高光域准确 可以产生高光 此题正确答案为B，见后 347 四.填空题，第3题 点坐标采用行向量形式 点坐标采用列向量形式 349 模1答案，二.多选题，第1题答案 ABC ABCD 错切变换是沿坐标轴错切，参考对象仍为坐标原点 350 模2答案，一.单选题，第1题答案 B C 350 一.单选题，第3题答案 B C 350 一.单选题，第4题答案 C D 350 二.多选题，第10题答案 ACD ABCD 350 二.多选题，第11题答案 CD BCD 352 模3答案，一.单选题，第1题答案 D B 352 二.多选题，第1题答案 BCE AD 352 二.多选题，第2题答案 BD B 352 二.多选题，第6题答案 BD BCD 354 第1行 $$\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 1 \ 1/27 &amp; 1/9 &amp; 1/3 &amp; 0 \ 8/27 &amp; 4/9 &amp; 1/3 &amp; 0 \ 1 &amp; 1 &amp; 1 &amp; 1 \end{bmatrix}$$ $$\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 1 \ 1/27 &amp; 1/9 &amp; 1/3 &amp; 1 \ 8/27 &amp; 4/9 &amp; 2/3 &amp; 1 \ 1 &amp; 1 &amp; 1 &amp; 1 \end{bmatrix}$$ P349, 模拟试题1，第四大题第3小题答案：$$T_1= \left[ \begin{matrix} 1 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 \ -2 &amp; -4 &amp; 1\end{matrix}\right] $$ $$T_2= \left[ \begin{matrix} cos600^\circ &amp; sin600^\circ &amp; 0 \ -sin600^\circ &amp; cos600^\circ &amp; 0 \ 0 &amp; 0 &amp; 1 \end{matrix} \right] =\left[ \begin{matrix} -1/2 &amp; -\sqrt{3}/2 &amp; 0 \ \sqrt{3}/2 &amp; -1/2 &amp; 0 \ 0 &amp; 0 &amp; 1 \end{matrix} \right]$$ $$T_3= \left[ \begin{matrix} 1 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 \ 2 &amp; 4 &amp; 1 \end{matrix} \right] $$ $$T= T_1T_2T_3= \left[ \begin{matrix} -1/2 &amp; -\sqrt{3}/2 &amp; 0\ \sqrt{3}/2 &amp; -1/2 &amp; 0 \ 3-2 \sqrt{3} &amp; 6+ \sqrt{3} &amp; 1 \end{matrix} \right] $$由 $ P^{‘}= PT$ 可得：$$ \left[ \begin{matrix} A^{‘} \ B^{‘} \ C^{‘} \end{matrix} \right] =\left[ \begin{matrix} A \ B \ C \end{matrix} \right] T = \left[ \begin{matrix} 2 &amp; 4 &amp; 1 \ 4 &amp; 4 &amp; 1 \ 4 &amp; 1 &amp; 1 \end{matrix} \right] T= \left[ \begin{matrix} 2 &amp; 4 &amp; 1 \ 1 &amp; 4-\sqrt{3} &amp; 1 \ 1-3\sqrt{3}/2 &amp; 11/2-\sqrt{3} &amp; 1 \end{matrix} \right]$$ P350, 模拟试题1，第四大题第4小题答案：由相似三角形关系可得$$ \frac{x^{‘}} {x} = \frac{d} {d-z} $$于是$$x^{‘} = \frac{xd} {d-z}= \frac{x} {1-\frac{z}{d}}$$同理有：$$y^{‘} = \frac{y} {1-\frac{z}{d}}$$另外，$z^{‘}=0$.于是有：$$ P^{‘} = \left[ \begin{matrix} x^{‘} \ y^{‘} \ z^{‘} \ 1\end{matrix}\right] =\left[ \begin{matrix} \frac{x} {1-\frac{z}{d}} \ \frac{y} {1-\frac{z}{d}} \ 0 \ 1\end{matrix}\right]\equiv \left[ \begin{matrix} x \ y \ 0 \ 1-\frac{z}{d}\end{matrix}\right] =\left[ \begin{matrix} 1 &amp; 0 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 0 \0 &amp; 0 &amp; -\frac{1}{d} &amp; 1 \\end{matrix}\right]\left[ \begin{matrix} x \ y \ z \ 1\end{matrix}\right] ＝ TP $$上式中$T$即为透视变换矩阵，其中$ \equiv$表示齐次坐标转化。顶点坐标计算：以G点为例，G点齐次坐标为(1,1,-1,1)，则由透视变换可知：$$ G^{‘} = TG =T \left[ \begin{matrix} 1 \ 1 \ -1 \ 1\end{matrix}\right] =\left[ \begin{matrix} 1 &amp; 0 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 0 \0 &amp; 0 &amp; -\frac{1}{d} &amp; 1 \\end{matrix}\right]\left[ \begin{matrix} 1 \ 1 \ -1 \ 1\end{matrix}\right] ＝ \left[ \begin{matrix} 1 \ 1 \ 0 \ 1+\frac{1}{d}\end{matrix}\right]\equiv \left[ \begin{matrix} \frac{d}{d+1} \ \frac{d}{d+1} \ 0 \ 1\end{matrix}\right] $$故透视变换后G点变为$G^{‘}=( \frac{d}{d+1}, \frac{d}{d+1}, 0)$. P351, 模拟试题2，第五大题第2小题答案：$$ cosi=\vec{L} \cdot \vec{N}=0.5, \vec{R} = 2cosi\vec{N}-\vec{L}=(-1/2,1/2,-\sqrt{2}/2).$$$$cos\theta= \vec{R} \cdot \vec{V} = -\sqrt{2}/2&lt;0, \vec{R}与\vec{V}夹角大于90度，因此\vec{V}方向上无镜面反射光，所以 cos\theta取0. $$$$\therefore I=I_{pa}k_a+I_p(k_dcosi+k_scos^n\theta)=1600.5+175(0.20.5+0)=97.5$$ P353, 模拟试题3，第五大题第1小题答案：$a=y_0-y_1=-4, b=x_1-x_0=8, d_0=a+0.5b=0; a+b=4, a=-4$，当$d_i&lt;0$时，中点M在直线下方，下一点取当前点P的右上方点，记为NE，同时$d_{i+1}=d_i+a+b$；当$d_i\geq0$时，中点M在直线上方，下一点取当前点P的右侧点，记为E，同时$d_{i+1}=d_i+a$。根据中点线算法原理可得下表： x y $d_i$ Next Point 2 1 0 E 3 1 0-4=-4 NE 4 2 -4+4=0 E 5 2 0-4=-4 NE 6 3 -4+4=0 E 7 3 0-4=-4 NE 8 4 -4+4=0 E 9 4 0-4=-4 NE 10 5]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机图形学（OpenGL版）书中代码]]></title>
    <url>%2F2018%2F10%2F07%2FCGBook_Code%2F</url>
    <content type="text"><![CDATA[本处代码主要为各章中除章节末的编程实例之外的有关代码，现全部贴出以飨读者。 第3章 二维图形生成3.1 直线生成算法3.1.1 数值微分法123456789101112131415161718void LineDDA(int x1, int y1, int x2, int y2, int color)&#123; int dm=0; if (abs(x2-x1)&gt;= abs(y2-y1) //abs是求绝对值的函数 dm=abs(x2-x1); //x为计长方向 else dm=abs(y2-y1); //y为计长方向 float dx=(float)(x2-x1)/dm; //当x为计长方向时，dx的值为1 float dy=(float)(y2-y1)/dm; //当y为计长方向时，dy的值为1 float x=x1+0.5; float y=y1+0.5; for (int i=0; i&lt; dm; i++) &#123; setpixel( (int)x, (int)y, color); x+=dx; y+=dy; &#125;&#125; 3.1.2 逐点比较法1234567891011121314151617181920212223void PrintLine(int x1, int y1, int x2, int y2, int color)&#123; int x, y, xA, yA; if (y1&gt;y2) //平移直线的坐标，使y值较小的点位于坐标原点 &#123; yA=y1-y2; xA=x1-x2; &#125; else &#123;yA=y2-y1; xA=x2-x1; &#125; int F=x=y=0; int n=abs(xA)+abs(yA); for (int i=0; i&lt;n; i++) &#123; if (xA&gt;0) &#123; //如果斜率为正 if (F&gt;=0) &#123;x++; F-=yA;&#125; else &#123; y++; F+=xA; &#125;&#125;else &#123;//如果斜率为负 if (F&gt;=0) &#123;y++; F+=xA;&#125; else &#123; x--; F+=yA; &#125;&#125;if (y1&gt;y2) setpixel(x+x2, y+y2, color); else setpixel(x+x1, y+y1, color); &#125; 3.1.3 Bresenham画线法123456789101112131415161718192021222324252627282930313233343536373839404142void swap_value (int* a, int* b)&#123; int temp=*a; *a=*b; *b=temp;&#125;void Bres_Line(int x1, int y1, int x2, int y2, int color)&#123; setpixel(x1,y1, color); int dx=abs(x2-x1); int dy=abs(y2-y1); if (dx==0&amp;&amp;dy==0) return; int flag=0; if (dx&lt;dy) //下面将斜率变换至0≤|k|≤1区间 &#123; flag=1; swap_value(&amp;x1, &amp;y1); swap_value(&amp;x2, &amp;y2); swap_value(&amp;dx, &amp;dy); &#125; int tx=(x2-x1)&gt;0 ? 1:-1; int ty=(y2-y1)&gt;0 ? 1: -1; int curx=x1; int cury=y1; int dS=2*dy; int dT=2*(dy-dx); int d=dS-dx; while (curx!=x2) &#123; if (d&lt;0) d+=dS; else &#123;cury+=ty; d+=dT; &#125; if (flag) setpixel(cury, curx, color); else setpixel(curx, cury, color); curx+=tx; &#125;&#125; 3.1.4 中点画线法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051void MidPLine(int x0, int y0, int x1, int y1, int color)&#123; int a, b, d, x, y,tag=0; if(abs(x1-x0)&lt;abs(y1-y0)) //若斜率的绝对值大于1，将坐标和坐标互换 &#123; swap(&amp;x0,&amp;y0); swap(&amp;x1,&amp;y1); tag=1; &#125; if(x0&gt;x1)//保证x0&lt;x1 &#123; swap(&amp;x0,&amp;x1); swap(&amp;y0,&amp;y1); &#125; a=y0-y1; b=x1-x0; d=a+b/2; if(y0&lt;y1)//斜率为正 &#123; x=x0; y=y0; setPixel(x, y, 255); while (x&lt;x1) &#123; if (d&lt;0) &#123;x++; y++; d=d+a+b; &#125; else &#123;x++; d+=a;&#125; if(tag)//斜率大于1 setPixel(y, x, color); //互换 else setPixel(x, y, color); &#125; /* while */ &#125; else//斜率为负(y0&gt;=y1) &#123; x=x1; y=y1; setPixel(x, y, 255); while (x&gt;x0) &#123; if (d&lt;0) &#123;x--; y++; d=d-a+b; &#125; else &#123;x--; d-=a;&#125; if(tag)//斜率大于1 setPixel(y, x, color); //互换 else setPixel(x, y, color); &#125; /* while */ &#125;&#125; 3.2 圆弧绘制算法3.2.1 数值微分法1. Bresenham算法12345678910111213141516171819202122232425262728293031323334//8路对称void Cirpot(int x0, int y0, int x, int y, int color)&#123; SetPixel((x0+x), (y0+y), color); SetPixel((x0+y), (y0+x), color); SetPixel((x0+y), (y0-x), color); SetPixel((x0+x), (y0-y), color ); SetPixel((x0-x), (y0-y), color ); SetPixel((x0-y), (y0-x), color ); SetPixel((x0-y), (y0+x), color); SetPixel((x0-x), (y0+y), color);&#125;void Bres_Circle(int x0, int y0, double r)&#123; int x,y,d; x=0; y=(int)r; d=int(3-2*r); while(x&lt;y) &#123; Cirpot( x0,y0,x,y); if(d&lt;0) d+=4*x+6; else &#123; d+=4*(x-y)+10; y--; &#125; x++; &#125; if(x==y) Cirpot( x0,y0,x,y);&#125; 2. 中点画圆算法1234567891011121314151617181920//Cirpot函数与上述Bresenham算法代码中的Cirpot函数相同void MidPoint_Circle (int x0, int y0, int r, int color)&#123; int x=0; int y=r; int d=1- r; //是d=1.25 – r取整后的结果 Cirpot (x0, y0, x, y, color); while ( x&lt;y) &#123; if (d&lt;0) d+=2*x+3; else &#123; d+= 2(x-y) +5; y--; &#125; x++; Cirpot ( x0, y0, x, y, color); &#125;&#125; 3.2.2 角度离散法绘制圆弧和椭圆弧1234567891011121314151617181920212223void Arc_OpenGL(int xc, int yc, double r, double ts, double te)&#123; double pi=3.1415926; if (te &lt; ts) //当终止角比起始角还小时，则将终止角加上2π te += 2*pi; double dt = 0.4/r; //取角度离散值，使其与半径r成反比 int n=(int)(( te – ts ) / dt + 0.5 ); //确定总步数 double ta = ts; int x = xc + int ( r*cos(ts) ); int y = yc + int ( r*sin(ts) ); glBegin(GL_LINE_STRIP); //如果绘制整圆，选GL_LINE_LOOP更好 glVertex2f( x, y ); for(int i=1;i&lt;=n;i++) &#123; ta+=dt; double cost = cos ( ta ); double sint = sin ( ta ); x = int ( xc + r * cost ); y = int ( yc + r * sint ); glVertex2f ( x, y ); &#125; glEnd();&#125; 3.3.1 种子填充算法1234567891011121314151617181920//四连通漫水法伪代码void FloodFill (x, y, newcolor, boundaryColor)&#123; Stack stack; stack.Push(Pixel(x, y)); //把种子像素(x,y)推入栈中 while (! stack.Empty()) //当栈不空时循环执行以下代码 &#123; pixel=stack.Pop(); //从栈顶弹出一个像素 //当处理内定义区域时，用if (pixel.Color !=newcolor)判断即可 if (pixel.Color !=newcolor &amp;&amp; pixel.Color !=boundaryColor) &#123; xx=pixel.x; yy=pixel.y; setpixel( xx, yy, newcolor, boundaryColor); stack. Push ( Pixel (xx-1, yy )) ; stack. Push ( Pixel( xx, yy+1)); stack. Push ( Pixel (xx+1, yy )); stack.Push ( Pixel(xx, yy-1)); &#125; &#125;&#125; 第5章 二维观察5.3.2 直线裁剪1. Cohen-Sutherland编码裁剪算法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# define LEFT 1# define RIGHT 2# define BOTTOM 4# define TOP 8void encode(float x, float y, float XL, float XR, float YB, float YT, int* code)&#123; int c = 0; if (x&lt;XL) c = c|LEFT; else if (x&gt;XR) c = c|RIGHT; if (y&lt;YB) c = c|BOTTOM; else if(y&gt;YT) c = c|TOP; *code=c; return;&#125;void C_S_LineClip(float *x1, float *y1, float *x2, float *y2, float XL,float XR, float YB, float YT)&#123; int code1,code2,code; float x, y; encode(x1, y1, XL, XR, YB, YT, &amp;code1); encode(x2, y2, XL, XR, YB, YT, &amp;code1); while (code1!=0 || code2!=0) &#123; if ((code1 &amp; code2)!=0) return; code = code1; if (code1==0) code = code2; if ((LEFT &amp; code)!=0) &#123; //线段与左边界相交 x = XL; y = y1+(y2-y1)*(XL-x1)/(x2-x1); &#125; else if ((RIGHT &amp; code)!=0) //线段与右边界相交 &#123; x = XR; y = y1+(y2-y1)*(XR-x1)/(x2-x1); &#125; else if ((BOTTOM &amp; code)!=0) //线段与下边界相交 &#123; y = YB; x= x1+(x2-x1)*(YB-y1)/(y2-y1); &#125; else if ((TOP &amp; code)!=0) //线段与上边界相交 &#123; y = YT; x= x1+(x2-x1)*(YT-y1)/(y2-y1); &#125; if (code==code1)&#123; *x1 = x; *y1 = y; encode(x, y, XL, XR, YB, YT, &amp;code1); &#125; else&#123; *x2 = x; *y2 = y; encode(x, y, XL, XR, YB, YT, &amp;code2); &#125; &#125; return; &#125; 2．Liang-Barsky参数化裁剪算法123456789101112131415161718192021222324252627282930313233343536373839404142//x1,y1,x2,y2为直线端点坐标，XL,XR,YB,YT为窗口边界信息int L_B_LineClip(float *x1, float *y1, float *x2, float *y2, float XL,float XR, float YB, float YT)&#123; float u1 = 0, u2 = 1, dx = x2 – x1, dy; //u1为始点参数，初值0；u2为终点参数，初值1 if (clipTest(-dx, x1-XL, &amp;u1, &amp;u2)) //计算左边界交点参数，更新u1,u2 if (clipTest(dx, XR-x1, &amp;u1, &amp;u2)) //计算右边界交点参数，更新u1,u2 &#123; dy=y2-y1; if(clipTest(-dy, y1-YB, &amp;u1, &amp;u2)) //计算下边界交点参数，更新u1,u2 if (clipTest(dy, YT-y1, &amp;u1, &amp;u2))//计算上边界交点参数，更新u1,u2 &#123; if(u2 &lt; 1)&#123; *x2 = x1+u2*dx; //根据u2计算终点坐标 *y2 = y1+u2*dy; &#125; if(u1 &gt; 0)&#123; *x1 += u1*dx; //根据u1计算始点坐标 *y1 += u1*dy; &#125; return 1; &#125; &#125; return 0;&#125;int clipTest(float p, float q,float* u1,float* u2) //计算交点参数&#123; float r; int retVal = 1; if (p &lt; 0)&#123; r= q/p; if (r&gt;*u2) retVal = 0; else if (r&gt;*u1) *u1 = r; &#125; else if (p &gt; 0)&#123; r= q/p; if (r&lt;*u1) retVal = 0; else if (r &lt; *u2) *u2 = r; &#125; else if (q &lt; 0) retVal = 0; return retVal;&#125; 第7章 三维对象7.3.5 编程实例——简单实体构建123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;gl/glut.h&gt; #include&lt;iostream&gt;using namespace std;float rtri;float rquad; GLfloat points0[5][3] =&#123;&#123; 0, 1, 0&#125;, &#123;-1, -1, 1&#125;, &#123; 1, -1, 1&#125;, &#123; 1, -1, -1&#125;,&#123;-1, -1,-1&#125;&#125;;GLfloat points1[8][3]=&#123; &#123; 1, 1, -1 &#125;, &#123;-1, 1, -1&#125;, &#123;-1, 1, 1&#125;, &#123; 1, 1, 1&#125;, &#123; 1, -1, 1 &#125;, &#123;-1, -1, 1&#125;, &#123;-1,-1,-1&#125;, &#123; 1, -1, -1&#125;&#125;;GLfloat Colors0[4][3]=&#123;&#123;1,0,0&#125;,&#123;0,1,0&#125;, &#123;0,0,1&#125;,&#123;1,1,0&#125;&#125;; //四棱锥的颜色//下行是立方体的颜色GLfloat Colors1[6][3]=&#123;&#123;0,1,0&#125;,&#123;1,0.5,0&#125;,&#123;1,0,0&#125;,&#123;1,1,0&#125;,&#123;0,0,1&#125;,&#123;1,0,1&#125;&#125;;int vertice0[4][3]=&#123;&#123;0,1,2&#125;,&#123;0,2,3&#125;,&#123;0,3,4&#125;,&#123;0,4,1&#125;&#125;; //四棱锥的顶点号序列//下行是立方体的顶点号序列int vertice1[6][4]=&#123;&#123;0,1,2,3&#125;,&#123;4,5,6,7&#125;,&#123;3,2,5,4&#125;,&#123;7,6,1,0&#125;,&#123;2,1,6,5&#125;, &#123;0,3,4,7&#125;&#125;;void InitGL ( GLvoid ) &#123; glShadeModel(GL_SMOOTH); glClearColor(1.0f, 1.0f, 1.0f, 1.0f); glClearDepth(1.0f); glEnable(GL_DEPTH_TEST); glDepthFunc(GL_LEQUAL); glEnable ( GL_COLOR_MATERIAL ); glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);&#125;void CreatePyramid()&#123; glBegin(GL_TRIANGLES); for(int i=0;i&lt;4;i++) &#123; glColor3fv(Colors0[i]); for(int j=0;j&lt;3;j++) &#123; int VtxId=vertice0[i][j]; glVertex3fv(points0[VtxId]); &#125; &#125; glEnd(); glBegin( GL_QUADS); //构建底面 glColor3f(1.0f, 1.0f, 1.0f ); for(i=0;i&lt;4;i++) glVertex3fv(points0[i]); glEnd();&#125;void CreateCube()&#123; glBegin(GL_QUADS); for(int i=0;i&lt;6;i++) &#123; glColor3fv(Colors1[i]); for(int j=0;j&lt;4;j++) &#123; int VtxId=vertice1[i][j]; glVertex3fv(points1[VtxId]); &#125; &#125; glEnd(); &#125;void display ( void ) &#123; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glLoadIdentity(); glPushMatrix(); glTranslatef(-1.5f,0.0f,-6.0f); //平移至左侧 glRotatef(rtri,0.0f,1.0f,0.0f); //旋转一个角度 CreatePyramid(); //创建三角塔 glLoadIdentity(); //将矩阵归一化回原样 glTranslatef(1.5f,0.0f,-6.0f); //平移到右侧 glRotatef(rquad,1.0f,0.0f,0.0f); //旋转一个角度 CreateCube(); //创建立方体 glPopMatrix(); rtri+=0.2f; //修改三角塔旋转角度 rquad-=0.15f; //修改立方体的旋转角度 glutSwapBuffers ( ); &#125;void reshape ( int width , int height ) &#123; if (height==0) height=1; glViewport(0,0,width,height); glMatrixMode(GL_PROJECTION); glLoadIdentity(); gluPerspective(45.0f,(GLfloat)width/(GLfloat)height,0.1f,100.0f); glMatrixMode(GL_MODELVIEW); glLoadIdentity(); &#125;void main ( int argc, char** argv ) &#123; glutInit ( &amp;argc, argv ); glutInitDisplayMode ( GLUT_RGBA | GLUT_DOUBLE ); glutInitWindowSize ( 600, 400 ); glutCreateWindow ( &quot;Pyramid and cube&quot; ); InitGL(); glutDisplayFunc ( display ); glutReshapeFunc ( reshape ); glutIdleFunc ( display ); glutMainLoop ( );&#125; 7.4.2 Hermite曲线123456789101112131415161718192021222324252627282930313233343536373839class Point //点类&#123;Double x，y;Point(double vx， double vy)&#123; This.x=vx; This.y=vy;&#125;Point operator – (Point p) //重载运算符“-”&#123; Return new Point(x-p.x ， y-p.y);&#125;&#125;//在p1和p2之间绘制一条Hermite曲线//p1-p0为p1处的切线矢量，p3-p2为p2处的切线矢量//参数区间[0，1]被离散为count份void HermiteCurve(Point p0，Point p1，Point p2，Point p3，int count)&#123; Point r1，r2; //切线矢量 r1 = p1 - p0; //调用重载- r2 = p3 - p2; double t = 0.0; dt = 1.0 / count; moveto(p1.x，p1.y); //设置起点 for(int i=0; i&lt;count+1; i++) &#123; double tt = t * t; double ttt = tt * t; double F1，F2，F3，F4; //调和函数 F1 = 2 * ttt - 3 * tt + 1; F2 = -2 * ttt + 3 * tt; F3 = ttt - 2 * tt + t; F4 = ttt - tt; double x = p1.x * F1 + p2.x * F2 + r1.x * F3 + r2.x * F4; double y = p1.y * F1 + p2.y * F2 + r1.y * F3 + r2.y * F4; lineto(x，y); t+=dt; &#125;&#125; 7.4.3 Bezier曲线3．三次Bezier曲线的绘制123456789101112131415161718192021//绘制由p0，p1，p2，p3确定的Bezier曲线//参数区间[0，1]被离散为count份void BezierCurve(Point p0,Point p1,Point p2,Point p3,int count)&#123; double t = 0.0; dt = 1.0 / count; moveto(p1.x,p1.y); //设置起点 for(int i=0; i&lt;count+1; i++) &#123; double F1,F2,F3,F4,x,y; //调和函数 double u = 1.0 – t ; F1 = u * u * u ; F2 = 3 * t * u * u; F3 = 3 * t * t * u; F4 = t * t * t; x = p0.x * F1 + p1.x * F2 + p2.x * F3 + p3.x * F4; y = p0.y * F1 + p1.y * F2 + p2.y * F3 + p3.y * F4; lineto(x,y); t+=dt; &#125;&#125; 4．离散生成Beizer曲线的de Casteljau算法123456789101112131415161718192021222324252627282930void Casteljau(Point p0, Point p1, Point p2, Point p3) &#123; double t=0; int count=20; double dt=1.0/count; MoveTo(p0); for(int i=0;i&lt;count;i++) &#123; Point p01,p11,p21,p02,p12,p03; p01.x=(1-t)*p0.x+t*p1.x; p01.y=(1-t)*p0.y+t*p1.y; p11.x=(1-t)*p1.x+t*p2.x; p11.y=(1-t)*p1.y+t*p2.y; p21.x=(1-t)*p2.x+t*p3.x; p21.y=(1-t)*p2.y+t*p3.y; p02.x=(1-t)*p01.x+t*p11.x; p02.y=(1-t)*p01.y+t*p11.y; p12.x=(1-t)*p11.x+t*p21.x; p12.y=(1-t)*p11.y+t*p21.y; p03.x=(1-t)*p02.x+t*p12.x; p03.y=(1-t)*p02.y+t*p12.y; dc-&gt;LineTo(p03); t+=dt; &#125;&#125; 第8章真实感图形技术8.3.4 OpenGL中的颜色模型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;GL/glut.h&gt;void init(void)&#123; glClearColor(1.0,1.0,1.0,0.0); glShadeModel(GL_SMOOTH);&#125;void triangle(void)&#123; glBegin (GL_TRIANGLES); glColor3f (1.0f, 0.0f, 0.0f); glVertex2f (5.0f,5.0f); glColor3f (0.0f, 1.0f, 0.0f); glVertex2f (25.0f,5.0f); glColor3f (0.0f, 0.0f, 1.0f); glVertex2f (5.0f,25.0f); glEnd (); glBegin (GL_TRIANGLES); glColor3f (1.0f, 1.0f, 0.0f); glVertex2f (26.0f,25.0f); glColor3f (0.0f, 1.0f, 1.0f); glVertex2f (26.0f,5.0f); glColor3f (1.0f, 0.0f, 1.0f); glVertex2f (6.0f,25.0f); glEnd ();&#125;void display(void)&#123; glClear(GL_COLOR_BUFFER_BIT); triangle(); glFlush();&#125;void reshape(int w,int h)&#123; glViewport(0,0,(GLsizei)w, (GLsizei)h); glMatrixMode(GL_PROJECTION); glLoadIdentity(); if(w &lt;= h) gluOrtho2D(0.0,30.0,0.0,30.0*(GLfloat)h/(GLfloat)w); else gluOrtho2D(0.0,30.0*(GLfloat)w/(GLfloat)h,0.0,30.0); glMatrixMode(GL_MODELVIEW);&#125;int main(int argc, char** argv)&#123; glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE); glutInitWindowSize(500, 500); glutInitWindowPosition(100, 100); glutCreateWindow(&quot;OpenGL颜色函数例程&quot;); init(); glutDisplayFunc(display); glutReshapeFunc(reshape); glutMainLoop(); return 0;&#125;]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebGL画点程序v1]]></title>
    <url>%2F2018%2F10%2F05%2FWebGL%E7%94%BB%E7%82%B9%E7%A8%8B%E5%BA%8Fv1%2F</url>
    <content type="text"><![CDATA[本文程序实现画一个点的任务，如下图。其中，点的位置直接给定（“硬编码”）在顶点着色器中。 整个程序包含两个文件，分别是： 1. HelloPoint1.html12345678910111213&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;画一个点&lt;/title&gt; &lt;/head&gt; &lt;body onload="startup()"&gt; &lt;canvas id="myGLCanvas" width="640" height="480"&gt; &lt;/canvas&gt; &lt;/body&gt; &lt;script type="text/javascript" src="HelloPoint1.js"&gt; &lt;/script&gt;&lt;/html&gt; 2. HelloPoint1.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071var gl;function createGLContext(canvas) &#123; var names = ["webgl", "experimental-webgl"]; var context = null; for (var i=0; i &lt; names.length; i++) &#123; try &#123; context = canvas.getContext(names[i]); //获取webgl context绘图上下文 &#125; catch(e) &#123;&#125; if (context) &#123; break; &#125; &#125; if (context) &#123; context.viewportWidth = canvas.width; context.viewportHeight = canvas.height; &#125; else &#123; alert("Failed to create WebGL context!"); &#125; return context;&#125;function loadShader(type, shaderSource) &#123; var shader = gl.createShader(type); gl.shaderSource(shader, shaderSource); gl.compileShader(shader); if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) &#123; alert("Error compiling shader" + gl.getShaderInfoLog(shader)); gl.deleteShader(shader); return null; &#125; return shader; &#125;function setupShaders() &#123; //顶点着色器程序 var vertexShaderSource = 'void main()&#123; \n' + ' gl_Position = vec4(0.0, 0.0, 0.0, 1.0); \n' + //gl_Position指定了点的位置 ' gl_PointSize = 10.0; \n' + '&#125; \n'; //片元着色器程序 var fragmentShaderSource = 'void main()&#123; \n' + ' gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); \n' + //gl_FragColor指定像素的颜色 '&#125; \n'; var vertexShader = loadShader(gl.VERTEX_SHADER, vertexShaderSource); var fragmentShader = loadShader(gl.FRAGMENT_SHADER, fragmentShaderSource); var shaderProgram = gl.createProgram(); gl.attachShader(shaderProgram, vertexShader); gl.attachShader(shaderProgram, fragmentShader); gl.linkProgram(shaderProgram); if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) &#123; alert("Failed to setup shaders"); &#125; gl.useProgram(shaderProgram); gl.program= shaderProgram;&#125;function startup()&#123; var canvas = document.getElementById('myGLCanvas');//获取&lt;canvas&gt;元素 gl = createGLContext(canvas); setupShaders(); gl.clearColor(0.0, 0.0, 0.0, 1.0);//指定清空&lt;canvas&gt;的颜色 gl.clear(gl.COLOR_BUFFER_BIT);//清空&lt;canvas&gt; gl.drawArrays(gl.POINTS, 0, 1);//从第0个元素开始，在指定位置（gl_Position）画1个点 &#125; 参考代码 Hello Point——WebGL, http://www.cnblogs.com/idealer3d/p/3513838.html Professional WebGL Programming: Developing 3D Graphics for the Web,Listing 2-1,http://media.wiley.com/product_ancillary/60/11199688/DOWNLOAD/Listing-2-1.html 转载请注明出处：http://www.cnblogs.com/opengl/p/7262596.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[个人博客搭建备忘录]]></title>
    <url>%2F2018%2F10%2F05%2F%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%A4%87%E5%BF%98%E5%BD%95%2F</url>
    <content type="text"><![CDATA[我的博客最开始是在博客园上，后面转到CSDN.因为CSDN的审核机制感觉不好，因此趁着今年国庆搭建了一个独立博客。现在将搭建过程记录下来，供自己以后备忘，同时也供有兴趣的读者参考。 独立博客搭建过程按步骤可分为三步：（1）博客网站构建；（2）发布到托管网站；（3）自定义域名绑定。其中，第3步非必须，只针对有自定义域名情形。 一. 博客网站构建根据自己的学习与了解，目前通过GitHub来搭建个人博客，可以有两种常见的方式：Jekyll和Hexo。下面对这两种方式分别简单介绍。 1. Jekyll方式(1) 拉取博客模板到GitHub上fork拉取某个Jekyll类型博客模板的库，例如https://github.com/xudailong/xudailong.github.io； (2) 博客名称修改点击页面中上部Insights旁边的Settings，进入设置页面，修改库名为；xxx.github.io，其中xxx为你的GitHub用户名，当你在浏览器的新窗口输入：xxx.github.io时，应该能就能访问到这个博客了，只是此时这个博客里面显示内容和xudailong.github.io内容一样。 (3) 博客内容修改（i）博客主题修改主要是在_config.yml文件中，可以对照原有文件修改； （ii）博客文章修改_posts主要用来放博客文章，因此可以根据自己要求，删除无关文章，并添加自己的文章。这里文章对应的文件为markdown文件格式，文件命名为时间加标题，如2015-02-12-create-my-blog-with-jekyll.md。 说明 Jeklly 是什么 ?Jekyll从核心上来说是一个文本转换引擎。该系统内部的工作原理是：你输入一些用自己喜爱的标记语言格式书写的文本，可以是Markdown、Textile或纯粹的HTML，它将这些文本混合后放入一个或一整套页面布局当中。在整个过程中，你可以自行决定你的站点URL的模式、以及哪些数据将被显示在页面中，等等。这一切都将通过严格的文本编辑完成，而生成的Web界面则是最终的产品。 github pages与jeklly关系Jekyll is the engine behind GitHub Pages.Every GitHub Page is run through Jekyll when you push content to a specially named branch within your repository.即：提交到github-pages的内容会经过jeklly处理，转换为静态的html，前期是结构必须符合jeklly的要求。 Jeklly是否一定要在本地安装 ?本地安装目的是为了方便调试问题，所以不是必须的，安装比较繁琐。推荐：找一个满意的模板，clone下来简单修改，很少需要在本地调试。如需要本地安装，请参考：https://643435675.github.io/2015/02/15/create-my-blog-with-jekyll/ 2. Hexo方式(1) 安装工作环境 安装node 到Node.js官网下载相应平台的最新版本，一路安装即可； 安装hexo使用以下命令安装hexo到全局$ npm install -g hexo然后输入命令hexo -v显示hexo的版本号即为安装成功。(2) 博客文件夹初始化新建一个文件夹为博客网站所在文件夹（如Blog），然后进入Blog目录，下面所有的命令行操作都是在这个文件夹下进行的。用下面的命令初始化该文件夹，并生成一篇“hello word”的文章在\source_posts文件夹下：$ hexo init(3) 生成静态页面执行以下命令把文章编译为静态页面：$ hexo generate(4) 生成静态页面执行以下命令把文章编译为静态页面，生成在public中的html文件：$ hexo generate(5) 本地启动执行以下命令，本地启动服务，在浏览器中输入http://localhost:4000/查看生成的页面效果。如果不成功，可以换一个端口试试，如5000。$ hexo server -p 4000二. 发布到托管网站1. 发布到GitHub/Gitee/Coding可以通过GitHub Desktop工具来发布与同步。2. 发布到七牛云可以通过七牛云的同步工具来发布与同步。三. 自定义域名绑定1. 购买域名 GoDaddy，新加坡，可以使用支付宝; DNSPod，腾讯平台。还有许多其他平台，不一一列举。2. GitHub设置自定义域名点击GitHub页面中上部Insights旁边的Settings，进入设置页面，修改Custom domain为你购买的域名。3. 域名解析设置如果是在GoDaddy上购买的域名，可以直接在该网站内设置，也可以用DNSPod来设置，设置方法请参考：https://www.jianshu.com/p/05289a4bc8b2 参考文献 Github搭建个人博客, https://blog.csdn.net/xudailong_blog/article/details/78762262 hexo VS jekyll, https://blog.csdn.net/scythe666/article/details/51956821#cmid=212488 Hexo博客系列（六）：部署到七牛, http://www.isetsuna.com/hexo/deploy-qiniu/ 利用7牛云搭建hexo个人博客, https://blog.csdn.net/quuqu/article/details/51851574 如何搭建一个独立博客——简明Github Pages与Hexo教程，https://www.jianshu.com/p/05289a4bc8b2]]></content>
  </entry>
  <entry>
    <title><![CDATA[实验3 地理空间数据可视化]]></title>
    <url>%2F2018%2F10%2F05%2FPrj3_GeographyDataVisualization%2F</url>
    <content type="text"><![CDATA[一. 实验目的和要求1. 了解地理空间数据可视化知识，了解和学习地理空间数据可视化三种典型可视化方式，即点、线与区域。2. 学习并掌握获取地图上位置信息的方法。3. 学习并掌握绘制地图方法，及在地图上加点、线及区域的方法。二. 实验内容1. 获取自己家乡的地理位置信息；2. 根据《鲜活的数据》第8章8.2.3介绍的方法与提供的数据，在R中绘制基本地图与散点图，并存为PDF文件；3. 将上一步所得的PDF文件，导入Illustrator，以教材图8-10为模板，并在图中增加中国的数据，完成图8-10，并添上自己的署名，最终成图请以中文版为参考。图8-10英文版如下图所示： 中文版如下图所示： 再次提醒：最终成图是在参考图8-10的基础上，增加中国的数据。 三. 实验报告实验报告中的实验过程请根据实验内容结合自己的具体实验过程填写； 实验结果： （1）自己家乡及其位置信息； （2）图8-10，可以手绘，可以文字描述，也可以将图缩小打印贴上； 实验分析部分可以对整个实验过程进行回顾与总结，可以从以下一些问题角度进行分析： 实验难度与自身水平相比如何？ 通过实验有无发现自己有待提高的知识或能力吗？ 碰到什么问题？如何解决？ 本次实验有何收获或心得？简单介绍下。]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>可视化</tag>
        <tag>地理空间数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实验2 关系可视化]]></title>
    <url>%2F2018%2F10%2F05%2F%E5%AE%9E%E9%AA%8C2_%E5%85%B3%E7%B3%BB%E5%8F%AF%E8%A7%86%E5%8C%96%2F</url>
    <content type="text"><![CDATA[一. 实验目的和要求1. 了解关系可视化知识，了解和学习散点图、饼图、堆叠柱形图、板块层级图和直方图等常见图表类型；2. 学习图形语法方式绘图；3. 学习与巩固R+Illustrator可视化绘图模式。二. 实验内容1. 根据《鲜活的数据》第6章6.2.1介绍的方法与提供的数据，在R中绘制基本散点图，并存为PDF文件；2. 将上一步所得的PDF文件，导入Illustrator，以教材图6-7为模板，完成图6-7，并添上自己的署名。图6-7英文如下图所示，大家提交作品文字部分按中文版处理，图形效果参考英文版。 三. 实验报告实验报告中的实验过程请根据实验内容结合自己的具体实验过程填写； 实验结果为上图，可以手绘，可以文字描述，也可以将图缩小打印贴上； 实验分析部分可以对整个实验过程进行回顾与总结，可以从以下一些问题角度进行分析： 实验难度与自身水平相比如何？ 通过实验有无发现自己有待提高的知识或能力吗？ 碰到什么问题？如何解决？ 本次实验有何收获或心得？简单介绍下。附加-实验步骤1. 下载编程工具R, 推荐用RStudio免费版（free），下载地址：https://www.rstudio.com/products/rstudio/download/；2. 数据下载地址：http://datasets.flowingdata.com/crimeRatesByState2005.csv。3. 用R绘图，具体如下：（1）安装ggplot2包：启动RStudio后，菜单栏点击Tools&gt;Install Packages…中输入ggplot2，安装；（2）新建一个R Script文件；（4）启用ggplot2包：在新建的R Script文件中输入下面代码来启用ggplot2包：library(ggplot2)将光标放在上面代码所在行，点击菜单Code-&gt;Run Select Lines运行本行代码；快捷键Ctrl+Enter;以下每行代码都需运行，不再重复。（3）数据读取：输入以下代码来读取CSV文件数据到crime变量中：crime&lt;-read.csv(‘c:\Users\…\crimeRatesByState2005.csv’,sep=”,”, header=TRUE)其中，请将“c:\Users\…\crimeRatesByState2005.csv”改为你自己的文件路径。（4）数据整理：通过以下两行代码来剔除掉华盛顿特区和全美平均值，并将剔除后的数据存入crime2变量中：crime2 &lt;- crime[crime$state != “District of Columbia”,] crime2 &lt;- crime2[crime2$state != “United States”,] （5）ggplot2绘图：通过以下代码来绘制：（i）基本图形：以数据集中的murder列为x坐标，burglary为y坐标绘制散点图如下：ggplot(crime2, aes(x = murder, y = burglary)) + geom_point() （ii）增加坐标轴范围：ggplot(crime2, aes(x = murder, y = burglary)) +geom_point()+ xlim(0, 10)+ ylim(0, 1200) （iii）增加回归曲线：ggplot(crime2, aes(x = murder, y = burglary)) + geom_point()+ xlim(0, 10)+ ylim(0, 1200)+ geom_smooth() （6）保存绘图：在R绘图窗口中点击Export-&gt;Save as PDF将绘图结果保存为pdf，注意保存选项的Orientation。 4. 用Illustrator来修饰完善：将所保存的绘图结果Pdf文件导入到Illustrator中，进行修饰完善，具体过程不再赘述，请自行百度解决。]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>可视化</tag>
        <tag>地理空间数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实验1 时间趋势可视化]]></title>
    <url>%2F2018%2F10%2F05%2F%E5%AE%9E%E9%AA%8C1_%E6%97%B6%E9%97%B4%E8%B6%8B%E5%8A%BF%E5%8F%AF%E8%A7%86%E5%8C%96%2F</url>
    <content type="text"><![CDATA[一. 实验目的1. 了解时间趋势可视化知识，学习与掌握柱状图的生成方法；2. 学习并掌握R+Illustrator可视化绘图模式。二. 实验内容1. 根据《鲜活的数据》第４章4.2.1提供的数据，在R中绘制柱状图，并存为PDF文件；2. 将上一步所得的PDF文件，导入Illustrator，参考教材图4-5样图，对其修改与修饰，并添上自己的署名。图4-5英文版如下图所示： 注意：pdf文件请按“序号_姓名”格式命名，以便于查找与定位。]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>可视化</tag>
        <tag>时间趋势</tag>
      </tags>
  </entry>
</search>
