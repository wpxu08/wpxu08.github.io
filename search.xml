<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[实验0.1 FreeGlut配置简介]]></title>
    <url>%2F2020%2F05%2F20%2FCG%E5%AE%9E%E9%AA%8C0.1%20FreeGlut%E9%85%8D%E7%BD%AE%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[1．FreeGlut简介：先介绍下Glut库。GLUT最初由MarkKilgard编写，从OpenGL Redbook（红宝书）第二版起就用来作为示例程序的支持环境，直到第八版为止（注：第九版开始改为GLFW）。从那时起，GLUT因为其简单、可用性广、可移植性强，被广泛应用于各种OpenGL实际应用中。Glut最新版本为3.7版，大致在1998年8月停止维护和更新，同时其代码也没有开源。Freeglut是Glut库(OpenGL Utility Toolkit，OpenGL实用工具包)的免费开源替代品。它是由Pawel W. Olszta在1999年12月创建，最新版本为2015年3月的3.0版本。 2. FreeGlut获取可以选择源码自己编译，也可以直接使用编译好的文件。(1) 源码下载链接：http://prdownloads.sourceforge.net/freeglut/freeglut-3.0.0.tar.gz?download(2) 编译好的文件下载链接：https://www.transmissionzero.co.uk/software/freeglut-devel/其中如果以VS为编程环境，可以直接下载上述链接页面中的MSVC包（“freeglut 3.0.0 MSVC Package”）。 3．FreeGlut配置下面以freeglut-MSVC.zip文件介绍FreeGlut在VS2017中的配置。(1) 头文件 将freeglut\include\GL目录复制到 Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.16.27023\include目录下;(2) 库文件 将freeglut\lib\freeglut.lib文件复制到Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.16.27023\lib\x86目录下; 将freeglut\lib\x64\freeglut.lib文件复制到Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.16.27023\lib\x64目录下;(3) Dll文件 64位Windows系统： 将freeglut\bin\freeglut.dll文件复制到C:\Windows\SysWOW64目录下; 将freeglut\bin\x64\freeglut.dll文件复制到c:\Windows\System32目录下; 32位Windows系统： 将freeglut\bin\freeglut.dll文件复制到c:\Windows\System32目录下;4．补充为防止出现“无法打开文件“freeglutd.lib””的错误，需要在代码文件中#include &lt;GL/glut.h&gt;语句前加上#define NDEBUG，如下所示：123#define NDEBUG #include &lt;GL/glut.h&gt;...... 原因请参考文章Freeglut中无法打开文件”freeglutd.lib”。]]></content>
      <categories>
        <category>计算机图形学基础（第2版）</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实验0.2 OpenGL程序创建与运行]]></title>
    <url>%2F2020%2F05%2F20%2FCG%E5%AE%9E%E9%AA%8C0.2%20OpenGL%E7%A8%8B%E5%BA%8F%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[下列介绍与图示均以Microsoft Visual Studio Community 2017版本（下面简称为VS）为例，其它版本类似。 1. 创建控制台应用（1）点击：文件&rarr;新建&rarr;项目，如下图所示：选择“Visual C++ &rarr; Windows桌面&rarr;控制台应用”：在名称对应文本框中，修改工程名称为“HelloPoint”：点击“确定”，得到缺省工程结果，如图所示： 2. 生成解决方案，确认生成没有错误(1) 点击菜单：生成&rarr;生成解决方案，如图所示：(2) 观察VS下方“输出”窗口中提示：“生成：成功1个…”，确认生成没有错误，如下图所示： 3. OpenGL代码替换，解决方案重新生成、运行在运行下面代码前，请先配置FreeGlut库，这是一个OpenGL程序的支持环境库，具体信息与配置方法请参考： FreeGlut配置简介。(1) 将原有缺省代码替换为下列OpenGL代码：1234567891011121314151617181920212223242526#include &lt;GL/glut.h&gt;void myDisplay(void)&#123; glClearColor(0.0, 0.0, 0.0, 0.0); glClear(GL_COLOR_BUFFER_BIT); glPointSize(3); glBegin(GL_POINTS); glColor3f(1.0f, 0.0f, 0.0f); glVertex2f(-0.4f, -0.4f); glColor3f(0.0f, 1.0f, 0.0f); glVertex2f(0.0f, 0.0f); glColor3f(0.0f, 0.0f, 1.0f); glVertex2f(0.4f, 0.4f); glEnd(); glFlush();&#125;int main(int argc, char *argv[])&#123; glutInit(&amp;argc, argv); glutInitWindowPosition(100, 100); glutInitWindowSize(400, 400); glutCreateWindow(&quot;Hello Point!&quot;); glutDisplayFunc(&amp;myDisplay); glutMainLoop(); return 0;&#125; 替换完成后并重新生成，结果如下图所示：(2)运行程序，观察程序运行结果点击菜单：调试&rarr;开始执行（不调试），如图所示：弹出两个窗口，其中一个窗口中显示红、绿、蓝三个点，即为程序运行结果，如图所示： 至此，完成了一个简单的OpenGL程序创建与运行。]]></content>
      <categories>
        <category>计算机图形学基础（第2版）</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实验1 OpenGL初识]]></title>
    <url>%2F2020%2F05%2F19%2FCG%E5%AE%9E%E9%AA%8C1%20OpenGL%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[一．实验目的 熟悉编程环境；了解光栅图形显示器的特点；了解计算机绘图的特点； 利用VC+OpenGL作为开发平台设计程序，以能够在屏幕上生成任意一个像素点作为本实验的目标。 二．实验内容 了解和使用VC的开发环境，理解简单的OpenGL程序结构。 掌握OpenGL提供的基本图形函数，尤其是生成点的函数。 三．实验原理1. 基本语法常用的程序设计语言，如C、C++、Pascal、Fortran和Java等，都支持OpenGL的开发。这里只讨论C版本下OpenGL的语法。OpenGL基本函数均使用gl作为函数名的前缀，如glClearColor()；实用函数则使用glu作为函数名的前缀，如gluSphere()。OpenGL基本常量的名字以GL_开头，如GL_LINE_LOOP；实用常量的名字以GLU_开头，如GLU_FILL。一些函数如glColor*()（定义颜色值），函数名后可以接不同的后缀以支持不同的数据类型和格式。如glColor3b(…)、glColor3d(…)、glColor3f(…)和glColor3bv(…)等，这几个函数在功能上是相似的，只是适用于不同的数据类型和格式，其中3表示该函数带有三个参数，b、d、f分别表示参数的类型是字节型、双精度浮点型和单精度浮点型，v则表示这些参数是以向量形式出现的。为便于移植，OpenGL定义了一些自己的数据类型，如GLfloat、GLvoid，它们其实就是C语言中的float和void。在gl.h文件中可以看到以下定义： 12typedef float GLfloat;typedef void GLvoid; 一些基本的数据类型都有类似的定义项。 2. 程序的基本结构OpenGL程序的基本结构可分为三个部分：(1) 初始化： 主要是设置一些OpenGL的状态开关，如颜色模式（RGBA或Alpha）的选择、是否作光照处理（若有的话，还需设置光源的特性）、深度检测、裁剪等。这些状态一般都用函数glEnable(…), glDisable(…)来设置，“…”表示特定的状态。(2) 观察设置： 设置观察坐标系下的取景模式和取景框位置大小。主要利用了三个函数。 void glViewport(left,top,right,bottom)：设置在屏幕上的窗口大小，四个参数描述屏幕窗口四个角上的坐标（以像素表示）。 void glOrtho(left,right,bottom,top,near,far)：设置投影方式为正交投影（平行投影），其取景体积是一个各面均为矩形的六面体。 void gluPerspective(fovy,aspect,zNear,zFar)：设置投影方式为透视投影，其取景体积是一个截头锥体。 (3) 程序主体： 使用OpenGL的库函数构造几何物体对象的数学描述，包括点线面的位置和拓扑关系、几何变换、光照处理等。 3. 状态机制OpenGL的工作方式是一种状态机制，它可以进行各种状态或模式设置，这些状态或模式在重新改变它们之前一直有效。例如，当前颜色就是一个状态变量，在这个状态改变之前，绘制的每个像素都将使用该颜色，直到当前颜色被设置为其他颜色为止。OpenGL中大量使用了这种状态机制，如颜色模式、投影模式、单双显示缓存区的设置、背景色的设置、光源的位置和特性等。许多状态变量可以通过glEnable()、glDisable()这两个函数来设置成有效或无效状态，如是否设置光照、是否进行深度检测等；在被设置成有效状态之后，绝大部分状态变量都有一个默认值。通常情况下，可以用下列四个函数来获取某个状态变量的值：glGetBooleanv、glGetDouble、glGetFloatv和glGetIntegerv。究竟选择哪个函数应该根据所要获得的返回值的数据类型来决定。还有些状态变量有特殊的查询函数，如glGetLight*、glGetError和glPolygonStipple等。另外，使用glPushAttrib和glPopAttrib函数，可以存储和恢复最近的状态变量的值。只要有可能，都应该使用这些函数，因为它们比其他查询函数的效率更高。 4. OpenGL的坐标系统如下图A.1所示,OpengGL坐标与绘图区坐标关系如下，绘图区的中心点：(0.0,0.0,0.0)绘图区的右上角点：(1.0,1.0,0.0)绘图区的左下角点：(-1.0, 1.0,0.0) 图A.1 OpengGL绘图区对应坐标 四．实验代码在运行下面实验代码前，请先配置FreeGlut库，这是一个OpenGL程序的支持环境库，具体信息与配置方法请参考： FreeGlut配置简介。之后，学习掌握OpenGL程序创建与运行，具体请参考OpenGL程序创建与运行。123456789101112131415161718192021222324252627282930313233343536#include &lt;GL/glut.h&gt;void myDisplay(void)&#123; glClearColor(0.0, 0.0, 0.0, 0.0); glClear(GL_COLOR_BUFFER_BIT); glColor3f (1.0f, 1.0f, 1.0f); glRectf(-0.5f, -0.5f, 0.5f, 0.5f); glBegin (GL_TRIANGLES); glColor3f (1.0f, 0.0f, 0.0f); glVertex2f (0.0f, 1.0f); glColor3f (0.0f, 1.0f, 0.0f); glVertex2f (0.8f, -0.5f); glColor3f (0.0f, 0.0f, 1.0f); glVertex2f (-0.8f, -0.5f); glEnd (); glPointSize(3); glBegin (GL_POINTS); glColor3f (1.0f, 0.0f, 0.0f); glVertex2f (-0.4f, -0.4f); glColor3f (0.0f, 1.0f, 0.0f); glVertex2f (0.0f, 0.0f); glColor3f (0.0f, 0.0f, 1.0f); glVertex2f (0.4f, 0.4f); glEnd (); glFlush();&#125;int main(int argc, char *argv[])&#123; glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE); glutInitWindowPosition(100, 100); glutInitWindowSize(400, 400); glutCreateWindow(&quot;Hello World!&quot;); glutDisplayFunc(&amp;myDisplay); glutMainLoop(); return 0;&#125; 该程序的作用是在一个黑色的窗口中央画一个矩形、三角形和三个点，如图A.2（a）所示。下面对主要语句进行说明。首先，需要包含GLUT的头文件：#include &lt;GL/glut.h&gt;。一般，OpenGL程序还要包含&lt;GL/gl.h&gt;和&lt;GL/glu.h&gt;，但GLUT的头文件中已经自动将这两个文件包含了，不必再次包含。然后看main函数。int main(int argc, char *argv[])，这个是带命令行参数的main函数。注意main函数中的各语句，除了最后的return之外，其余全部以glut开头。这种以glut开头的函数都是GLUT工具包所提供的函数。下面对用到的几个函数进行介绍。 glutInit，对GLUT进行初始化，这个函数必须在其他的GLUT使用之前调用一次。其格式比较固定，一般都是glutInit(&amp;argc, argv)就行。 glutInitDisplayMode，设置显示方式，其中GLUT_RGB表示使用RGB颜色，与之对应的还有GLUT_INDEX（表示使用索引颜色）。GLUT_SINGLE表示使用单缓冲，与之对应的还有GLUT_DOUBLE（使用双缓冲）。更多信息，以后的实验教程会有介绍。 glutInitWindowPosition，设置窗口在屏幕中的位置。 glutInitWindowSize，设置窗口的大小。 glutCreateWindow，根据前述设置的信息创建窗口。参数将被作为窗口的标题。注意：窗口被创建后，并不立即显示到屏幕上。需要调用glutMainLoop才能看到窗口。 glutDisplayFunc，设置一个函数，当需要进行画图时，这个函数就会被调用（暂且这样理解）。 glutMainLoop，进行一个消息循环（现在只需知道这个函数可以显示窗口，并且等待窗口关闭后才会返回）。 在glutDisplayFunc函数中，我们设置了“当需要画图时，请调用myDisplay函数”。于是myDisplay函数就用来画图。观察myDisplay函数中的三个函数调用，发现它们都以gl开头。这种以gl开头的函数都是OpenGL的标准函数，下面对用到的函数进行介绍。 glClearColor(0.0, 0.0, 0.0, 0.0) ：将清空颜色设为黑色（思考：为什么会有四个参数？）。 glClear(GL_COLOR_BUFFER_BIT)：将窗口的背景设置为当前清空颜色。 glRectf：画一个矩形。四个参数分别表示了位于对角线上的两个点的横、纵坐标。 (4)glFlush：保证前面的OpenGL命令立即执行（而不是让它们在缓冲区中等待）。 五．实验提高根据示范程序，能否在原有结果基础上添加三条直线组成三角形，结果如图A.2（b）所示？ （a）示范程序结果 （b）加三角形后的结果图A.2 实验1]]></content>
      <categories>
        <category>计算机图形学基础（第2版）</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客搭建备忘录]]></title>
    <url>%2F2020%2F01%2F19%2F%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%A4%87%E5%BF%98%E5%BD%95%2F</url>
    <content type="text"><![CDATA[我的博客最开始是在博客园上，后面转到CSDN.因为CSDN的审核机制感觉不好，因此趁着今年国庆搭建了一个独立博客。现在将搭建过程记录下来，供自己以后备忘，同时也供有兴趣的读者参考。 独立博客搭建过程按步骤可分为三步：（1）博客网站构建；（2）发布到托管网站；（3）自定义域名绑定。其中，第3步非必须，只针对有自定义域名情形。 一. 博客网站构建根据自己的学习与了解，目前通过GitHub来搭建个人博客，可以有两种常见的方式：Jekyll和Hexo。下面对这两种方式分别简单介绍。 1. Jekyll方式(1) 拉取博客模板到GitHub上fork拉取某个Jekyll类型博客模板的库，例如https://github.com/xudailong/xudailong.github.io； (2) 博客名称修改点击页面中上部Insights旁边的Settings，进入设置页面，修改库名为；xxx.github.io，其中xxx为你的GitHub用户名，当你在浏览器的新窗口输入：xxx.github.io时，应该能就能访问到这个博客了，只是此时这个博客里面显示内容和xudailong.github.io内容一样。 (3) 博客内容修改（i）博客主题修改主要是在_config.yml文件中，可以对照原有文件修改； （ii）博客文章修改_posts主要用来放博客文章，因此可以根据自己要求，删除无关文章，并添加自己的文章。这里文章对应的文件为markdown文件格式，文件命名为时间加标题，如2015-02-12-create-my-blog-with-jekyll.md。 说明 Jeklly 是什么 ?Jekyll从核心上来说是一个文本转换引擎。该系统内部的工作原理是：你输入一些用自己喜爱的标记语言格式书写的文本，可以是Markdown、Textile或纯粹的HTML，它将这些文本混合后放入一个或一整套页面布局当中。在整个过程中，你可以自行决定你的站点URL的模式、以及哪些数据将被显示在页面中，等等。这一切都将通过严格的文本编辑完成，而生成的Web界面则是最终的产品。 github pages与jeklly关系Jekyll is the engine behind GitHub Pages.Every GitHub Page is run through Jekyll when you push content to a specially named branch within your repository.即：提交到github-pages的内容会经过jeklly处理，转换为静态的html，前期是结构必须符合jeklly的要求。 Jeklly是否一定要在本地安装 ?本地安装目的是为了方便调试问题，所以不是必须的，安装比较繁琐。推荐：找一个满意的模板，clone下来简单修改，很少需要在本地调试。如需要本地安装，请参考：https://643435675.github.io/2015/02/15/create-my-blog-with-jekyll/ 2. Hexo方式(1) 安装工作环境 安装node 到Node.js官网(https://nodejs.org/en/)下载相应平台的最新版本，一路安装即可； 安装hexo使用以下命令安装hexo到全局$ npm install -g hexo然后输入命令hexo -v显示hexo的版本号即为安装成功。(2) 博客文件夹初始化新建一个文件夹为博客网站所在文件夹（如Blog），然后进入Blog目录，下面所有的命令行操作都是在这个文件夹下进行的。用下面的命令初始化该文件夹，并生成一篇“hello word”的文章在\source_posts文件夹下：$ hexo init(3) 生成静态页面执行以下命令把文章编译为静态页面：$ hexo generate(4) 生成静态页面执行以下命令把文章编译为静态页面，生成在public中的html文件：$ hexo generate(5) 本地启动执行以下命令，本地启动服务，在浏览器中输入http://localhost:4000/查看生成的页面效果。如果不成功，可以换一个端口试试，如5000。另外，可以在命令行窗口用“netstat -an”命令查询端口占用情况。$ hexo server -p 5000二. 发布到托管网站1. 发布到GitHub/Gitee/Coding可以通过GitHub Desktop工具来发布与同步。2. 发布到七牛云可以通过七牛云的同步工具来发布与同步。三. 自定义域名绑定1. 购买域名 GoDaddy，新加坡，可以使用支付宝; DNSPod，腾讯平台。还有许多其他平台，不一一列举。2. GitHub设置自定义域名点击GitHub页面中上部Insights旁边的Settings，进入设置页面，修改Custom domain为你购买的域名。3. 域名解析设置如果是在GoDaddy上购买的域名，可以直接在该网站内设置，也可以用DNSPod来设置，设置方法请参考：https://www.jianshu.com/p/05289a4bc8b2 参考文献 Github搭建个人博客, https://blog.csdn.net/xudailong_blog/article/details/78762262 hexo VS jekyll, https://blog.csdn.net/scythe666/article/details/51956821#cmid=212488 Hexo博客系列（六）：部署到七牛, http://www.isetsuna.com/hexo/deploy-qiniu/ 利用7牛云搭建hexo个人博客, https://blog.csdn.net/quuqu/article/details/51851574 如何搭建一个独立博客——简明Github Pages与Hexo教程，https://www.jianshu.com/p/05289a4bc8b2]]></content>
  </entry>
  <entry>
    <title><![CDATA[WebGL画点程序v1]]></title>
    <url>%2F2020%2F01%2F19%2FWebGL%E7%94%BB%E7%82%B9%E7%A8%8B%E5%BA%8Fv1%2F</url>
    <content type="text"><![CDATA[本文程序实现画一个点的任务，如下图。其中，点的位置直接给定（“硬编码”）在顶点着色器中。 整个程序包含两个文件，分别是： 1. HelloPoint1.html12345678910111213&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;画一个点&lt;/title&gt; &lt;/head&gt; &lt;body onload="startup()"&gt; &lt;canvas id="myGLCanvas" width="640" height="480"&gt; &lt;/canvas&gt; &lt;/body&gt; &lt;script type="text/javascript" src="HelloPoint1.js"&gt; &lt;/script&gt;&lt;/html&gt; 2. HelloPoint1.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071var gl;function createGLContext(canvas) &#123; var names = ["webgl", "experimental-webgl"]; var context = null; for (var i=0; i &lt; names.length; i++) &#123; try &#123; context = canvas.getContext(names[i]); //获取webgl context绘图上下文 &#125; catch(e) &#123;&#125; if (context) &#123; break; &#125; &#125; if (context) &#123; context.viewportWidth = canvas.width; context.viewportHeight = canvas.height; &#125; else &#123; alert("Failed to create WebGL context!"); &#125; return context;&#125;function loadShader(type, shaderSource) &#123; var shader = gl.createShader(type); gl.shaderSource(shader, shaderSource); gl.compileShader(shader); if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) &#123; alert("Error compiling shader" + gl.getShaderInfoLog(shader)); gl.deleteShader(shader); return null; &#125; return shader; &#125;function setupShaders() &#123; //顶点着色器程序 var vertexShaderSource = 'void main()&#123; \n' + ' gl_Position = vec4(0.0, 0.0, 0.0, 1.0); \n' + //gl_Position指定了点的位置 ' gl_PointSize = 10.0; \n' + '&#125; \n'; //片元着色器程序 var fragmentShaderSource = 'void main()&#123; \n' + ' gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); \n' + //gl_FragColor指定像素的颜色 '&#125; \n'; var vertexShader = loadShader(gl.VERTEX_SHADER, vertexShaderSource); var fragmentShader = loadShader(gl.FRAGMENT_SHADER, fragmentShaderSource); var shaderProgram = gl.createProgram(); gl.attachShader(shaderProgram, vertexShader); gl.attachShader(shaderProgram, fragmentShader); gl.linkProgram(shaderProgram); if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) &#123; alert("Failed to setup shaders"); &#125; gl.useProgram(shaderProgram); gl.program= shaderProgram;&#125;function startup()&#123; var canvas = document.getElementById('myGLCanvas');//获取&lt;canvas&gt;元素 gl = createGLContext(canvas); setupShaders(); gl.clearColor(0.0, 0.0, 0.0, 1.0);//指定清空&lt;canvas&gt;的颜色 gl.clear(gl.COLOR_BUFFER_BIT);//清空&lt;canvas&gt; gl.drawArrays(gl.POINTS, 0, 1);//从第0个元素开始，在指定位置（gl_Position）画1个点 &#125; 参考代码 Hello Point——WebGL, http://www.cnblogs.com/idealer3d/p/3513838.html Professional WebGL Programming: Developing 3D Graphics for the Web,Listing 2-1,http://media.wiley.com/product_ancillary/60/11199688/DOWNLOAD/Listing-2-1.html 转载请注明出处：http://www.cnblogs.com/opengl/p/7262596.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[实验4 个人大学数据可视化]]></title>
    <url>%2F2020%2F01%2F19%2FDV-Prj4_UniversityStudyVisualization%2F</url>
    <content type="text"><![CDATA[一. 实验目的和要求1. 复习前述可视化知识和方法。2. 综合应用前面所学可视化知识和方法，对大学学习与生活有关数据进行可视化。二. 实验内容1. 将自己9门专业主干课程成绩可视化：高级语言程序设计、离散数学、数据结构、计算机组成原理、操作系统原理、计算机网络、数据库系统原理、编译原理、软件工程；2. 将自己的前三年综合积分及其名次可视化；3. 总结自己的专业技能与其它技能，并根据技能水平对其可视化。技能水平建议分为一般，熟练，精通，专家四种：4. 回顾上大学至今自已去过的地方，将其可视化；5. 根据以上4方面的信息，制作一个简单的个人简历,打印稿下次上课前提交，电子稿提交到雨课堂。三. 实验报告实验报告中的实验过程请根据实验内容结合自己的具体实验过程填写； 实验结果： 简单的个人简历，可以手绘，可以文字描述，也可以将图缩小打印贴上； 实验分析部分可以对整个实验过程进行回顾与总结，可以从以下一些问题角度进行分析： 实验难度与自身水平相比如何？ 通过实验有无发现自己有待提高的知识或能力吗？ 碰到什么问题？如何解决？ 本次实验有何收获或心得？简单介绍下。]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实验3 地理空间数据可视化]]></title>
    <url>%2F2020%2F01%2F19%2FDV-Prj3_GeographyDataVisualization%2F</url>
    <content type="text"><![CDATA[一. 实验目的和要求1. 了解地理空间数据可视化知识，了解和学习地理空间数据可视化三种典型可视化方式，即点、线与区域。2. 学习并掌握获取地图上位置信息的方法。3. 学习并掌握绘制地图方法，及在地图上加点、线及区域的方法。二. 实验内容1. 获取自己家乡的地理位置信息；2. 根据《鲜活的数据》第8章8.2.3介绍的方法与提供的数据，在R中绘制基本地图与散点图，并存为PDF文件；3. 将上一步所得的PDF文件，导入Illustrator，以教材图8-10为模板，并在图中增加中国的数据，完成图8-10，并添上自己的署名，最终成图请以中文版为参考。图8-10英文版如下图所示： 中文版如下图所示： 再次提醒：最终成图是在参考图8-10的基础上，增加中国的数据。 三. 实验报告实验报告中的实验过程请根据实验内容结合自己的具体实验过程填写； 实验结果： （1）自己家乡及其位置信息； （2）图8-10，可以手绘，可以文字描述，也可以将图缩小打印贴上； 实验分析部分可以对整个实验过程进行回顾与总结，可以从以下一些问题角度进行分析： 实验难度与自身水平相比如何？ 通过实验有无发现自己有待提高的知识或能力吗？ 碰到什么问题？如何解决？ 本次实验有何收获或心得？简单介绍下。]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>可视化</tag>
        <tag>地理空间数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实验2 关系可视化]]></title>
    <url>%2F2020%2F01%2F19%2FDV-Prj2_%E5%85%B3%E7%B3%BB%E5%8F%AF%E8%A7%86%E5%8C%96%2F</url>
    <content type="text"><![CDATA[一. 实验目的和要求1. 了解关系可视化知识，了解和学习散点图、饼图、堆叠柱形图、板块层级图和直方图等常见图表类型；2. 学习图形语法方式绘图；3. 学习与巩固R+Illustrator可视化绘图模式。二. 实验内容1. 根据《鲜活的数据》第6章6.2.1介绍的方法与提供的数据，在R中绘制基本散点图，并存为PDF文件；2. 将上一步所得的PDF文件，导入Illustrator，以教材图6-7为模板，完成图6-7，并添上自己的署名。图6-7英文如下图所示，大家提交作品文字部分按中文版处理，图形效果参考英文版。 三. 实验报告实验报告中的实验过程请根据实验内容结合自己的具体实验过程填写； 实验结果为上图，可以手绘，可以文字描述，也可以将图缩小打印贴上； 实验分析部分可以对整个实验过程进行回顾与总结，可以从以下一些问题角度进行分析： 实验难度与自身水平相比如何？ 通过实验有无发现自己有待提高的知识或能力吗？ 碰到什么问题？如何解决？ 本次实验有何收获或心得？简单介绍下。附加-实验步骤1. 下载编程工具R, 推荐用RStudio免费版（free），下载地址：https://www.rstudio.com/products/rstudio/download/；2. 数据下载地址：http://datasets.flowingdata.com/crimeRatesByState2005.csv。3. 用R绘图，具体如下：（1）安装ggplot2包：启动RStudio后，菜单栏点击Tools&gt;Install Packages…中输入ggplot2，安装；（2）新建一个R Script文件；（4）启用ggplot2包：在新建的R Script文件中输入下面代码来启用ggplot2包：library(ggplot2)将光标放在上面代码所在行，点击菜单Code-&gt;Run Select Lines运行本行代码；快捷键Ctrl+Enter;以下每行代码都需运行，不再重复。（3）数据读取：输入以下代码来读取CSV文件数据到crime变量中：crime&lt;-read.csv(‘c:\Users\…\crimeRatesByState2005.csv’,sep=”,”, header=TRUE)其中，请将“c:\Users\…\crimeRatesByState2005.csv”改为你自己的文件路径。（4）数据整理：通过以下两行代码来剔除掉华盛顿特区和全美平均值，并将剔除后的数据存入crime2变量中：crime2 &lt;- crime[crime$state != “District of Columbia”,] crime2 &lt;- crime2[crime2$state != “United States”,] （5）ggplot2绘图：通过以下代码来绘制：（i）基本图形：以数据集中的murder列为x坐标，burglary为y坐标绘制散点图如下：ggplot(crime2, aes(x = murder, y = burglary)) + geom_point() （ii）增加坐标轴范围：ggplot(crime2, aes(x = murder, y = burglary)) +geom_point()+ xlim(0, 10)+ ylim(0, 1200) （iii）增加回归曲线：ggplot(crime2, aes(x = murder, y = burglary)) + geom_point()+ xlim(0, 10)+ ylim(0, 1200)+ geom_smooth() （6）保存绘图：在R绘图窗口中点击Export-&gt;Save as PDF将绘图结果保存为pdf，注意保存选项的Orientation。 4. 用Illustrator来修饰完善：将所保存的绘图结果Pdf文件导入到Illustrator中，进行修饰完善，具体过程不再赘述，请自行百度解决。]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>可视化</tag>
        <tag>地理空间数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实验1 时间趋势可视化]]></title>
    <url>%2F2020%2F01%2F19%2FDV-Prj1_%E6%97%B6%E9%97%B4%E8%B6%8B%E5%8A%BF%E5%8F%AF%E8%A7%86%E5%8C%96%2F</url>
    <content type="text"><![CDATA[一. 实验目的1. 了解时间趋势可视化知识，学习与掌握柱状图的生成方法；2. 学习并掌握R+Illustrator可视化绘图模式。二. 实验内容1. 根据《鲜活的数据》第４章4.2.1提供的数据，在R中绘制柱状图，并存为PDF文件；2. 将上一步所得的PDF文件，导入Illustrator，参考教材图4-5样图，对其修改与修饰，并添上自己的署名。图4-5英文版如下图所示： 注意：pdf文件请按“序号_姓名”格式命名，以便于查找与定位。]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>可视化</tag>
        <tag>时间趋势</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《计算机图形学基础（OpenGL版）》勘误表]]></title>
    <url>%2F2020%2F01%2F19%2FCGBook_Error%2F</url>
    <content type="text"><![CDATA[页码 行或位置 原内容 更正为 备注 38 9 (1MB) (128KB) 41 16 $$k=\Delta x/\Delta y$$ $$k=\Delta y/\Delta x$$ 43 9 $$d \leq 0$$ $$d \geq 0$$ 46 6 $$ s-t = s \frac{\Delta x}{\Delta y}(x_i+1)+2b+2y_i-1$$ $$ s-t = s \frac{\Delta x}{\Delta y}(x_i+1)+2b -2y_i-1$$ 46 倒数第4行 $$-1\leq1\leq0$$ $$0\leq k\leq 1$$ 47 26 int curx = x1; int curx = x1 + 1; 48 12 $$b=x_0-x_1$$ $$b=x_1-x_0$$ 51 19 令$T$点的坐标为$（x_i, y_i)$ 令$P$点的坐标为$（x_i, y_i)$ 52 倒数第3行 Cirpot(x0, y0, x, y) Cirpot(x0, y0, x, y, color) 53 9 Cirpot(x0, y0, x, y) Cirpot(x0, y0, x, y, color) 57 7 FloodFill FloodFill4 57 13-16 FloodFill4(…, newcolor) FloodFill4(…, newcolor, boundaryColor) 58-59 58页倒数第2行~59页第11行 见教材 从点P向任意方向发出一条射线，若该射线与多边形交点的个数为奇数，则P位于多边形内；若为偶数，则P位于多边形外部。当射线与多边形边界点的交点是多边形顶点时（该交点称为奇点，如图3-13的$P_3$，$P_4$，$P_5$和$P_6$情况），如果把每一个奇点简单地计为一个交点，则交点个数为偶数时P点可能在内部，如图3-13中的$P_4$情况。但若将每一个奇点都简单地计为两个交点，同样会导致错误的结果，如图3-13中的$P_3$和$P_5$情况。因此，必须按不同情况区别对待。一般来说，多边形的顶点可分为两类：极值点和非极值点。如果顶点相邻的两边在射线的同侧时，则称该顶点为极值点（如图3-13中的$Q_0$和$Q_1$）；否则称该顶点为非极值点（如图3-13中的$Q_2$）。为了保证射线法判别结果的正确性，奇点交点的计数可以根据上述分类来采用不同的方式。当奇点是多边形的极值点时，交点按照两个交点计算，否则，按一个交点计算，如图3.13所示。 59 图3-13 见教材 60 图3.16 65 倒数第4行 图3.22 图3.23 65 倒数第3行 $y_i+m/2$ $y_i-int(y_i)+m/2$ 73 6 $$ y’=rsin(\phi+\theta)=rcos \phi sin \theta - rsin \phi cos \theta $$ $$ y’=rsin(\phi+\theta)=rcos \phi sin \theta + rsin \phi cos \theta $$ 75 8 相对于y轴的反射 相对于x轴的反射 82/87 式(4.40/57) $$\begin{bmatrix} cos\theta &amp; \mathbf{-sin\theta} &amp; 0 \ \mathbf{sin\theta} &amp; cos\theta &amp; 0 \ 0 &amp; 0 &amp; 1 \ \end{bmatrix} $$ $$\begin{bmatrix} cos\theta &amp; \mathbf{sin\theta} &amp; 0 \ \mathbf{-sin\theta} &amp; cos\theta &amp; 0 \ 0 &amp; 0 &amp; 1 \ \end{bmatrix} $$ 117 2 $$T=R(\theta)T(-x_0, -y_0) =\begin{bmatrix} cos\theta &amp; \mathbf{sin\theta} &amp; 0 \ \mathbf{-sin\theta} &amp; cos\theta &amp; 0 \ 0 &amp; 0 &amp; 1 \ \end{bmatrix} \begin{bmatrix} 1 &amp; 0 &amp; -x_0 \0 &amp; 1 &amp; -y_0 \0 &amp; 0 &amp; 1 \end{bmatrix}$$ $$T=R(\theta)T(-x_0, -y_0) = \begin{bmatrix} cos\theta &amp; -sin\theta &amp; 0 \sin\theta &amp; cos\theta &amp; 0 \ 0 &amp; 0 &amp; 1 \end{bmatrix} \begin{bmatrix} 1 &amp; 0 &amp; -x_0 \0 &amp; 1 &amp; -y_0 \0 &amp; 0 &amp; 1 \end{bmatrix} $$ 122 15 $$t_1^{‘’}=(x_R-x_1)/dx$$ $$t_1^{‘’}=(y_B-y_1)/dy$$ 130 24 glLoadIdentity() 应移至void display(void)中的第1个glColor3f(0.0,0.0,1.0)后 参考5.5 Opengl编程实例－红蓝三角形 131 1 131 图5.17后 无 增加思考内容：“思考：教材中原代码中根据所给三角形顶点坐标，三角形应为一个正角形，为何显示时不是正角形呢？同时，在旋转后的三角形也发生了变形，请分析原因，并给出修改建议。提示：请从”glViewport()”函数入手。” 135 (6.2) $$u=\frac{V \times n}{\mid N \mid} = (u_x, u_y, u_z)$$ $$u=\frac{V \times n}{\mid V \times n \mid} = (u_x, u_y, u_z)$$ 151 (6.29) $$ \begin{bmatrix}x_p \ y_p \ 0 \ 1 \end{bmatrix} =\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\ 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix} \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\ 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; \frac{1}{d} &amp; \mathbf{ 1} \end{bmatrix} \begin{bmatrix} x_s \ y_s \ z_s \ 1 \end{bmatrix} = \begin{bmatrix} x_s \ y_s \ 0 \ \mathbf{1+ \frac{z_s}{d}} \end{bmatrix}$$ $$ \begin{bmatrix} x_p \ y_p \ 0 \ 1 \end{bmatrix} =\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\ 0 &amp; 1 &amp; 0 &amp; 0 \0 &amp; 0 &amp; 0 &amp; 0 \0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix} \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\ 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; \frac{1}{d} &amp; \mathbf{0}\end{bmatrix} \begin{bmatrix} x_s \ y_s \ z_s \ 1 \end{bmatrix} = \begin{bmatrix} x_s \ y_s \ 0 \ \mathbf{ \frac{z_s}{d} } \end{bmatrix}$$ 151 (6.31) $$ \begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\ 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; r &amp; \mathbf{1}\end{bmatrix} $$ $$ \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\ 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; r &amp; \mathbf{0}\end{bmatrix} $$ 151 (6.33) $$ \begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\ 0 &amp; 1 &amp; 0 &amp; 0 \0 &amp; 0 &amp; 1 &amp; 0 \ p &amp; 0 &amp; 0 &amp; \mathbf{1}\end{bmatrix} $$ $$ \begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 &amp; 0 \ p &amp; 0 &amp; 0 &amp; \mathbf{0 }\end{bmatrix} $$ 151 (6.34) $$ \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\ 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; q &amp; 0 &amp; \mathbf{1}\end{bmatrix} $$ $$ \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\ 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; q &amp; 0 &amp; \mathbf{0}\end{bmatrix} $$ 152 (6.35) 152 (6.35) 152 12 线性关系 非线性关系 152 (6.37) $$ a=\frac{-(z_{far}+z_{near})z_{near}}{z_{far}-z_{near}}$$ $$ a=\frac{z_{far}+z_{near}}{z_{near}(z_{far}-z_{near})}$$ 224 2 对于右手坐标系 对于OpenGL所采用的左手坐标系 烟台大学韩明峰指正 图8.17 8 深度缓冲器所有单元均置为最小 z值 深度缓冲器所有单元均置为最大 z值 为保持与图8.17一致而修改，原内容也没错，下同 11 若z &gt; ZB(x, y)，则ZB(x, y)=z 若z &lt; ZB(x, y)，则ZB(x, y)=z 20 ZB(x,y)单元置为最小值 ZB(x,y)单元置为最大值 26 if(z(x,y) &gt; ZB(x,y)) if(z(x,y) &lt; ZB(x,y)) 附录B 模拟试题及答案 页码 位置 原内容 更正 备注 337 图B.1 340 模2试题，一.单选题，第6题 $$T= \left[ \begin{matrix} 2 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 \ 1 &amp; 1 &amp; 1 \end{matrix} \right] $$ $$P^{‘}= PT =\left[ \begin{matrix} x &amp; y &amp; 1 \end{matrix} \right] \left[ \begin{matrix} 2 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 \ 1 &amp; 1 &amp; 1 \end{matrix} \right] $$ 345 模3试题，一.单选题，第1题B选项 高光域准确 可以产生高光 此题正确答案为B，见后 347 四.填空题，第3题 点坐标采用行向量形式 点坐标采用列向量形式 349 模1答案，二.多选题，第1题答案 ABC ABCD 错切变换是沿坐标轴错切，参考对象仍为坐标原点 350 模2答案，一.单选题，第1题答案 B C 350 一.单选题，第3题答案 B C 350 一.单选题，第4题答案 C D 350 二.多选题，第10题答案 ACD ABCD 350 二.多选题，第11题答案 CD BCD 352 模3答案，一.单选题，第1题答案 D B 352 二.多选题，第1题答案 BCE AD 352 二.多选题，第2题答案 BD B 352 二.多选题，第6题答案 BD BCD 354 第1行 $$\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 1 \ 1/27 &amp; 1/9 &amp; 1/3 &amp; 0 \ 8/27 &amp; 4/9 &amp; 1/3 &amp; 0 \ 1 &amp; 1 &amp; 1 &amp; 1 \end{bmatrix}$$ $$\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 1 \ 1/27 &amp; 1/9 &amp; 1/3 &amp; 1 \ 8/27 &amp; 4/9 &amp; 2/3 &amp; 1 \ 1 &amp; 1 &amp; 1 &amp; 1 \end{bmatrix}$$ P349, 模拟试题1，第四大题第3小题答案：$$T_1= \left[ \begin{matrix} 1 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 \ -2 &amp; -4 &amp; 1\end{matrix}\right] $$ $$T_2= \left[ \begin{matrix} cos600^\circ &amp; sin600^\circ &amp; 0 \ -sin600^\circ &amp; cos600^\circ &amp; 0 \ 0 &amp; 0 &amp; 1 \end{matrix} \right] =\left[ \begin{matrix} -1/2 &amp; -\sqrt{3}/2 &amp; 0 \ \sqrt{3}/2 &amp; -1/2 &amp; 0 \ 0 &amp; 0 &amp; 1 \end{matrix} \right]$$ $$T_3= \left[ \begin{matrix} 1 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 \ 2 &amp; 4 &amp; 1 \end{matrix} \right] $$ $$T= T_1T_2T_3= \left[ \begin{matrix} -1/2 &amp; -\sqrt{3}/2 &amp; 0\ \sqrt{3}/2 &amp; -1/2 &amp; 0 \ 3-2 \sqrt{3} &amp; 6+ \sqrt{3} &amp; 1 \end{matrix} \right] $$由 $ P^{‘}= PT$ 可得：$$ \left[ \begin{matrix} A^{‘} \ B^{‘} \ C^{‘} \end{matrix} \right] =\left[ \begin{matrix} A \ B \ C \end{matrix} \right] T = \left[ \begin{matrix} 2 &amp; 4 &amp; 1 \ 4 &amp; 4 &amp; 1 \ 4 &amp; 1 &amp; 1 \end{matrix} \right] T= \left[ \begin{matrix} 2 &amp; 4 &amp; 1 \ 1 &amp; 4-\sqrt{3} &amp; 1 \ 1-3\sqrt{3}/2 &amp; 11/2-\sqrt{3} &amp; 1 \end{matrix} \right]$$ P350, 模拟试题1，第四大题第4小题答案：由相似三角形关系可得$$ \frac{x^{‘}} {x} = \frac{d} {d-z} $$于是$$x^{‘} = \frac{xd} {d-z}= \frac{x} {1-\frac{z}{d}}$$同理有：$$y^{‘} = \frac{y} {1-\frac{z}{d}}$$另外，$z^{‘}=0$.于是有：$$ P^{‘} = \left[ \begin{matrix} x^{‘} \ y^{‘} \ z^{‘} \ 1\end{matrix}\right] =\left[ \begin{matrix} \frac{x} {1-\frac{z}{d}} \ \frac{y} {1-\frac{z}{d}} \ 0 \ 1\end{matrix}\right]\equiv \left[ \begin{matrix} x \ y \ 0 \ 1-\frac{z}{d}\end{matrix}\right] =\left[ \begin{matrix} 1 &amp; 0 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 0 \0 &amp; 0 &amp; -\frac{1}{d} &amp; 1 \\end{matrix}\right]\left[ \begin{matrix} x \ y \ z \ 1\end{matrix}\right] ＝ TP $$上式中$T$即为透视变换矩阵，其中$ \equiv$表示齐次坐标转化。顶点坐标计算：以G点为例，G点齐次坐标为(1,1,-1,1)，则由透视变换可知：$$ G^{‘} = TG =T \left[ \begin{matrix} 1 \ 1 \ -1 \ 1\end{matrix}\right] =\left[ \begin{matrix} 1 &amp; 0 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 0 \0 &amp; 0 &amp; -\frac{1}{d} &amp; 1 \\end{matrix}\right]\left[ \begin{matrix} 1 \ 1 \ -1 \ 1\end{matrix}\right] ＝ \left[ \begin{matrix} 1 \ 1 \ 0 \ 1+\frac{1}{d}\end{matrix}\right]\equiv \left[ \begin{matrix} \frac{d}{d+1} \ \frac{d}{d+1} \ 0 \ 1\end{matrix}\right] $$故透视变换后G点变为$G^{‘}=( \frac{d}{d+1}, \frac{d}{d+1}, 0)$. P351, 模拟试题2，第五大题第2小题答案：$$ cosi=\vec{L} \cdot \vec{N}=0.5, \vec{R} = 2cosi\vec{N}-\vec{L}=(-1/2,1/2,-\sqrt{2}/2).$$$$cos\theta= \vec{R} \cdot \vec{V} = -\sqrt{2}/2&lt;0, \vec{R}与\vec{V}夹角大于90度，因此\vec{V}方向上无镜面反射光，所以 cos\theta取0. $$$$\therefore I=I_{pa}k_a+I_p(k_dcosi+k_scos^n\theta)=1600.5+175(0.20.5+0)=97.5$$ P353, 模拟试题3，第五大题第1小题答案：$a=y_0-y_1=-4, b=x_1-x_0=8, d_0=a+0.5b=0; a+b=4, a=-4$，当$d_i&lt;0$时，中点M在直线下方，下一点取当前点P的右上方点，记为NE，同时$d_{i+1}=d_i+a+b$；当$d_i\geq0$时，中点M在直线上方，下一点取当前点P的右侧点，记为E，同时$d_{i+1}=d_i+a$。根据中点线算法原理可得下表： x y $d_i$ Next Point 2 1 0 E 3 1 0-4=-4 NE 4 2 -4+4=0 E 5 2 0-4=-4 NE 6 3 -4+4=0 E 7 3 0-4=-4 NE 8 4 -4+4=0 E 9 4 0-4=-4 NE 10 5]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机图形学（OpenGL版）书中代码]]></title>
    <url>%2F2020%2F01%2F19%2FCGBook_Code%2F</url>
    <content type="text"><![CDATA[本处代码主要为各章中除章节末的编程实例之外的有关代码，现全部贴出以飨读者。 第3章 二维图形生成3.1 直线生成算法3.1.1 数值微分法123456789101112131415161718void LineDDA(int x1, int y1, int x2, int y2, int color)&#123; int dm=0; if (abs(x2-x1)&gt;= abs(y2-y1) //abs是求绝对值的函数 dm=abs(x2-x1); //x为计长方向 else dm=abs(y2-y1); //y为计长方向 float dx=(float)(x2-x1)/dm; //当x为计长方向时，dx的值为1 float dy=(float)(y2-y1)/dm; //当y为计长方向时，dy的值为1 float x=x1+0.5; float y=y1+0.5; for (int i=0; i&lt; dm; i++) &#123; setpixel( (int)x, (int)y, color); x+=dx; y+=dy; &#125;&#125; 3.1.2 逐点比较法1234567891011121314151617181920212223void PrintLine(int x1, int y1, int x2, int y2, int color)&#123; int x, y, xA, yA; if (y1&gt;y2) //平移直线的坐标，使y值较小的点位于坐标原点 &#123; yA=y1-y2; xA=x1-x2; &#125; else &#123;yA=y2-y1; xA=x2-x1; &#125; int F=x=y=0; int n=abs(xA)+abs(yA); for (int i=0; i&lt;n; i++) &#123; if (xA&gt;0) &#123; //如果斜率为正 if (F&gt;=0) &#123;x++; F-=yA;&#125; else &#123; y++; F+=xA; &#125;&#125;else &#123;//如果斜率为负 if (F&gt;=0) &#123;y++; F+=xA;&#125; else &#123; x--; F+=yA; &#125;&#125;if (y1&gt;y2) setpixel(x+x2, y+y2, color); else setpixel(x+x1, y+y1, color); &#125; 3.1.3 Bresenham画线法123456789101112131415161718192021222324252627282930313233343536373839404142void swap_value (int* a, int* b)&#123; int temp=*a; *a=*b; *b=temp;&#125;void Bres_Line(int x1, int y1, int x2, int y2, int color)&#123; setpixel(x1,y1, color); int dx=abs(x2-x1); int dy=abs(y2-y1); if (dx==0&amp;&amp;dy==0) return; int flag=0; if (dx&lt;dy) //下面将斜率变换至0≤|k|≤1区间 &#123; flag=1; swap_value(&amp;x1, &amp;y1); swap_value(&amp;x2, &amp;y2); swap_value(&amp;dx, &amp;dy); &#125; int tx=(x2-x1)&gt;0 ? 1:-1; int ty=(y2-y1)&gt;0 ? 1: -1; int curx=x1; int cury=y1; int dS=2*dy; int dT=2*(dy-dx); int d=dS-dx; while (curx!=x2) &#123; if (d&lt;0) d+=dS; else &#123;cury+=ty; d+=dT; &#125; if (flag) setpixel(cury, curx, color); else setpixel(curx, cury, color); curx+=tx; &#125;&#125; 3.1.4 中点画线法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051void MidPLine(int x0, int y0, int x1, int y1, int color)&#123; int a, b, d, x, y,tag=0; if(abs(x1-x0)&lt;abs(y1-y0)) //若斜率的绝对值大于1，将坐标和坐标互换 &#123; swap(&amp;x0,&amp;y0); swap(&amp;x1,&amp;y1); tag=1; &#125; if(x0&gt;x1)//保证x0&lt;x1 &#123; swap(&amp;x0,&amp;x1); swap(&amp;y0,&amp;y1); &#125; a=y0-y1; b=x1-x0; d=a+b/2; if(y0&lt;y1)//斜率为正 &#123; x=x0; y=y0; setPixel(x, y, 255); while (x&lt;x1) &#123; if (d&lt;0) &#123;x++; y++; d=d+a+b; &#125; else &#123;x++; d+=a;&#125; if(tag)//斜率大于1 setPixel(y, x, color); //互换 else setPixel(x, y, color); &#125; /* while */ &#125; else//斜率为负(y0&gt;=y1) &#123; x=x1; y=y1; setPixel(x, y, 255); while (x&gt;x0) &#123; if (d&lt;0) &#123;x--; y++; d=d-a+b; &#125; else &#123;x--; d-=a;&#125; if(tag)//斜率大于1 setPixel(y, x, color); //互换 else setPixel(x, y, color); &#125; /* while */ &#125;&#125; 3.2 圆弧绘制算法3.2.1 数值微分法1. Bresenham算法12345678910111213141516171819202122232425262728293031323334//8路对称void Cirpot(int x0, int y0, int x, int y, int color)&#123; SetPixel((x0+x), (y0+y), color); SetPixel((x0+y), (y0+x), color); SetPixel((x0+y), (y0-x), color); SetPixel((x0+x), (y0-y), color ); SetPixel((x0-x), (y0-y), color ); SetPixel((x0-y), (y0-x), color ); SetPixel((x0-y), (y0+x), color); SetPixel((x0-x), (y0+y), color);&#125;void Bres_Circle(int x0, int y0, double r)&#123; int x,y,d; x=0; y=(int)r; d=int(3-2*r); while(x&lt;y) &#123; Cirpot( x0,y0,x,y); if(d&lt;0) d+=4*x+6; else &#123; d+=4*(x-y)+10; y--; &#125; x++; &#125; if(x==y) Cirpot( x0,y0,x,y);&#125; 2. 中点画圆算法1234567891011121314151617181920//Cirpot函数与上述Bresenham算法代码中的Cirpot函数相同void MidPoint_Circle (int x0, int y0, int r, int color)&#123; int x=0; int y=r; int d=1- r; //是d=1.25 – r取整后的结果 Cirpot (x0, y0, x, y, color); while ( x&lt;y) &#123; if (d&lt;0) d+=2*x+3; else &#123; d+= 2(x-y) +5; y--; &#125; x++; Cirpot ( x0, y0, x, y, color); &#125;&#125; 3.2.2 角度离散法绘制圆弧和椭圆弧1234567891011121314151617181920212223void Arc_OpenGL(int xc, int yc, double r, double ts, double te)&#123; double pi=3.1415926; if (te &lt; ts) //当终止角比起始角还小时，则将终止角加上2π te += 2*pi; double dt = 0.4/r; //取角度离散值，使其与半径r成反比 int n=(int)(( te – ts ) / dt + 0.5 ); //确定总步数 double ta = ts; int x = xc + int ( r*cos(ts) ); int y = yc + int ( r*sin(ts) ); glBegin(GL_LINE_STRIP); //如果绘制整圆，选GL_LINE_LOOP更好 glVertex2f( x, y ); for(int i=1;i&lt;=n;i++) &#123; ta+=dt; double cost = cos ( ta ); double sint = sin ( ta ); x = int ( xc + r * cost ); y = int ( yc + r * sint ); glVertex2f ( x, y ); &#125; glEnd();&#125; 3.3.1 种子填充算法1234567891011121314151617181920//四连通漫水法伪代码void FloodFill (x, y, newcolor, boundaryColor)&#123; Stack stack; stack.Push(Pixel(x, y)); //把种子像素(x,y)推入栈中 while (! stack.Empty()) //当栈不空时循环执行以下代码 &#123; pixel=stack.Pop(); //从栈顶弹出一个像素 //当处理内定义区域时，用if (pixel.Color !=newcolor)判断即可 if (pixel.Color !=newcolor &amp;&amp; pixel.Color !=boundaryColor) &#123; xx=pixel.x; yy=pixel.y; setpixel( xx, yy, newcolor, boundaryColor); stack. Push ( Pixel (xx-1, yy )) ; stack. Push ( Pixel( xx, yy+1)); stack. Push ( Pixel (xx+1, yy )); stack.Push ( Pixel(xx, yy-1)); &#125; &#125;&#125; 第5章 二维观察5.3.2 直线裁剪1. Cohen-Sutherland编码裁剪算法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# define LEFT 1# define RIGHT 2# define BOTTOM 4# define TOP 8void encode(float x, float y, float XL, float XR, float YB, float YT, int* code)&#123; int c = 0; if (x&lt;XL) c = c|LEFT; else if (x&gt;XR) c = c|RIGHT; if (y&lt;YB) c = c|BOTTOM; else if(y&gt;YT) c = c|TOP; *code=c; return;&#125;void C_S_LineClip(float *x1, float *y1, float *x2, float *y2, float XL,float XR, float YB, float YT)&#123; int code1,code2,code; float x, y; encode(x1, y1, XL, XR, YB, YT, &amp;code1); encode(x2, y2, XL, XR, YB, YT, &amp;code1); while (code1!=0 || code2!=0) &#123; if ((code1 &amp; code2)!=0) return; code = code1; if (code1==0) code = code2; if ((LEFT &amp; code)!=0) &#123; //线段与左边界相交 x = XL; y = y1+(y2-y1)*(XL-x1)/(x2-x1); &#125; else if ((RIGHT &amp; code)!=0) //线段与右边界相交 &#123; x = XR; y = y1+(y2-y1)*(XR-x1)/(x2-x1); &#125; else if ((BOTTOM &amp; code)!=0) //线段与下边界相交 &#123; y = YB; x= x1+(x2-x1)*(YB-y1)/(y2-y1); &#125; else if ((TOP &amp; code)!=0) //线段与上边界相交 &#123; y = YT; x= x1+(x2-x1)*(YT-y1)/(y2-y1); &#125; if (code==code1)&#123; *x1 = x; *y1 = y; encode(x, y, XL, XR, YB, YT, &amp;code1); &#125; else&#123; *x2 = x; *y2 = y; encode(x, y, XL, XR, YB, YT, &amp;code2); &#125; &#125; return; &#125; 2．Liang-Barsky参数化裁剪算法123456789101112131415161718192021222324252627282930313233343536373839404142//x1,y1,x2,y2为直线端点坐标，XL,XR,YB,YT为窗口边界信息int L_B_LineClip(float *x1, float *y1, float *x2, float *y2, float XL,float XR, float YB, float YT)&#123; float u1 = 0, u2 = 1, dx = x2 – x1, dy; //u1为始点参数，初值0；u2为终点参数，初值1 if (clipTest(-dx, x1-XL, &amp;u1, &amp;u2)) //计算左边界交点参数，更新u1,u2 if (clipTest(dx, XR-x1, &amp;u1, &amp;u2)) //计算右边界交点参数，更新u1,u2 &#123; dy=y2-y1; if(clipTest(-dy, y1-YB, &amp;u1, &amp;u2)) //计算下边界交点参数，更新u1,u2 if (clipTest(dy, YT-y1, &amp;u1, &amp;u2))//计算上边界交点参数，更新u1,u2 &#123; if(u2 &lt; 1)&#123; *x2 = x1+u2*dx; //根据u2计算终点坐标 *y2 = y1+u2*dy; &#125; if(u1 &gt; 0)&#123; *x1 += u1*dx; //根据u1计算始点坐标 *y1 += u1*dy; &#125; return 1; &#125; &#125; return 0;&#125;int clipTest(float p, float q,float* u1,float* u2) //计算交点参数&#123; float r; int retVal = 1; if (p &lt; 0)&#123; r= q/p; if (r&gt;*u2) retVal = 0; else if (r&gt;*u1) *u1 = r; &#125; else if (p &gt; 0)&#123; r= q/p; if (r&lt;*u1) retVal = 0; else if (r &lt; *u2) *u2 = r; &#125; else if (q &lt; 0) retVal = 0; return retVal;&#125; 第7章 三维对象7.3.5 编程实例——简单实体构建123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;gl/glut.h&gt; #include&lt;iostream&gt;using namespace std;float rtri;float rquad; GLfloat points0[5][3] =&#123;&#123; 0, 1, 0&#125;, &#123;-1, -1, 1&#125;, &#123; 1, -1, 1&#125;, &#123; 1, -1, -1&#125;,&#123;-1, -1,-1&#125;&#125;;GLfloat points1[8][3]=&#123; &#123; 1, 1, -1 &#125;, &#123;-1, 1, -1&#125;, &#123;-1, 1, 1&#125;, &#123; 1, 1, 1&#125;, &#123; 1, -1, 1 &#125;, &#123;-1, -1, 1&#125;, &#123;-1,-1,-1&#125;, &#123; 1, -1, -1&#125;&#125;;GLfloat Colors0[4][3]=&#123;&#123;1,0,0&#125;,&#123;0,1,0&#125;, &#123;0,0,1&#125;,&#123;1,1,0&#125;&#125;; //四棱锥的颜色//下行是立方体的颜色GLfloat Colors1[6][3]=&#123;&#123;0,1,0&#125;,&#123;1,0.5,0&#125;,&#123;1,0,0&#125;,&#123;1,1,0&#125;,&#123;0,0,1&#125;,&#123;1,0,1&#125;&#125;;int vertice0[4][3]=&#123;&#123;0,1,2&#125;,&#123;0,2,3&#125;,&#123;0,3,4&#125;,&#123;0,4,1&#125;&#125;; //四棱锥的顶点号序列//下行是立方体的顶点号序列int vertice1[6][4]=&#123;&#123;0,1,2,3&#125;,&#123;4,5,6,7&#125;,&#123;3,2,5,4&#125;,&#123;7,6,1,0&#125;,&#123;2,1,6,5&#125;, &#123;0,3,4,7&#125;&#125;;void InitGL ( GLvoid ) &#123; glShadeModel(GL_SMOOTH); glClearColor(1.0f, 1.0f, 1.0f, 1.0f); glClearDepth(1.0f); glEnable(GL_DEPTH_TEST); glDepthFunc(GL_LEQUAL); glEnable ( GL_COLOR_MATERIAL ); glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);&#125;void CreatePyramid()&#123; glBegin(GL_TRIANGLES); for(int i=0;i&lt;4;i++) &#123; glColor3fv(Colors0[i]); for(int j=0;j&lt;3;j++) &#123; int VtxId=vertice0[i][j]; glVertex3fv(points0[VtxId]); &#125; &#125; glEnd(); glBegin( GL_QUADS); //构建底面 glColor3f(1.0f, 1.0f, 1.0f ); for(i=0;i&lt;4;i++) glVertex3fv(points0[i]); glEnd();&#125;void CreateCube()&#123; glBegin(GL_QUADS); for(int i=0;i&lt;6;i++) &#123; glColor3fv(Colors1[i]); for(int j=0;j&lt;4;j++) &#123; int VtxId=vertice1[i][j]; glVertex3fv(points1[VtxId]); &#125; &#125; glEnd(); &#125;void display ( void ) &#123; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glLoadIdentity(); glPushMatrix(); glTranslatef(-1.5f,0.0f,-6.0f); //平移至左侧 glRotatef(rtri,0.0f,1.0f,0.0f); //旋转一个角度 CreatePyramid(); //创建三角塔 glLoadIdentity(); //将矩阵归一化回原样 glTranslatef(1.5f,0.0f,-6.0f); //平移到右侧 glRotatef(rquad,1.0f,0.0f,0.0f); //旋转一个角度 CreateCube(); //创建立方体 glPopMatrix(); rtri+=0.2f; //修改三角塔旋转角度 rquad-=0.15f; //修改立方体的旋转角度 glutSwapBuffers ( ); &#125;void reshape ( int width , int height ) &#123; if (height==0) height=1; glViewport(0,0,width,height); glMatrixMode(GL_PROJECTION); glLoadIdentity(); gluPerspective(45.0f,(GLfloat)width/(GLfloat)height,0.1f,100.0f); glMatrixMode(GL_MODELVIEW); glLoadIdentity(); &#125;void main ( int argc, char** argv ) &#123; glutInit ( &amp;argc, argv ); glutInitDisplayMode ( GLUT_RGBA | GLUT_DOUBLE ); glutInitWindowSize ( 600, 400 ); glutCreateWindow ( &quot;Pyramid and cube&quot; ); InitGL(); glutDisplayFunc ( display ); glutReshapeFunc ( reshape ); glutIdleFunc ( display ); glutMainLoop ( );&#125; 7.4.2 Hermite曲线123456789101112131415161718192021222324252627282930313233343536373839class Point //点类&#123;Double x，y;Point(double vx， double vy)&#123; This.x=vx; This.y=vy;&#125;Point operator – (Point p) //重载运算符“-”&#123; Return new Point(x-p.x ， y-p.y);&#125;&#125;//在p1和p2之间绘制一条Hermite曲线//p1-p0为p1处的切线矢量，p3-p2为p2处的切线矢量//参数区间[0，1]被离散为count份void HermiteCurve(Point p0，Point p1，Point p2，Point p3，int count)&#123; Point r1，r2; //切线矢量 r1 = p1 - p0; //调用重载- r2 = p3 - p2; double t = 0.0; dt = 1.0 / count; moveto(p1.x，p1.y); //设置起点 for(int i=0; i&lt;count+1; i++) &#123; double tt = t * t; double ttt = tt * t; double F1，F2，F3，F4; //调和函数 F1 = 2 * ttt - 3 * tt + 1; F2 = -2 * ttt + 3 * tt; F3 = ttt - 2 * tt + t; F4 = ttt - tt; double x = p1.x * F1 + p2.x * F2 + r1.x * F3 + r2.x * F4; double y = p1.y * F1 + p2.y * F2 + r1.y * F3 + r2.y * F4; lineto(x，y); t+=dt; &#125;&#125; 7.4.3 Bezier曲线3．三次Bezier曲线的绘制123456789101112131415161718192021//绘制由p0，p1，p2，p3确定的Bezier曲线//参数区间[0，1]被离散为count份void BezierCurve(Point p0,Point p1,Point p2,Point p3,int count)&#123; double t = 0.0; dt = 1.0 / count; moveto(p1.x,p1.y); //设置起点 for(int i=0; i&lt;count+1; i++) &#123; double F1,F2,F3,F4,x,y; //调和函数 double u = 1.0 – t ; F1 = u * u * u ; F2 = 3 * t * u * u; F3 = 3 * t * t * u; F4 = t * t * t; x = p0.x * F1 + p1.x * F2 + p2.x * F3 + p3.x * F4; y = p0.y * F1 + p1.y * F2 + p2.y * F3 + p3.y * F4; lineto(x,y); t+=dt; &#125;&#125; 4．离散生成Beizer曲线的de Casteljau算法123456789101112131415161718192021222324252627282930void Casteljau(Point p0, Point p1, Point p2, Point p3) &#123; double t=0; int count=20; double dt=1.0/count; MoveTo(p0); for(int i=0;i&lt;count;i++) &#123; Point p01,p11,p21,p02,p12,p03; p01.x=(1-t)*p0.x+t*p1.x; p01.y=(1-t)*p0.y+t*p1.y; p11.x=(1-t)*p1.x+t*p2.x; p11.y=(1-t)*p1.y+t*p2.y; p21.x=(1-t)*p2.x+t*p3.x; p21.y=(1-t)*p2.y+t*p3.y; p02.x=(1-t)*p01.x+t*p11.x; p02.y=(1-t)*p01.y+t*p11.y; p12.x=(1-t)*p11.x+t*p21.x; p12.y=(1-t)*p11.y+t*p21.y; p03.x=(1-t)*p02.x+t*p12.x; p03.y=(1-t)*p02.y+t*p12.y; dc-&gt;LineTo(p03); t+=dt; &#125;&#125; 第8章真实感图形技术8.3.4 OpenGL中的颜色模型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;GL/glut.h&gt;void init(void)&#123; glClearColor(1.0,1.0,1.0,0.0); glShadeModel(GL_SMOOTH);&#125;void triangle(void)&#123; glBegin (GL_TRIANGLES); glColor3f (1.0f, 0.0f, 0.0f); glVertex2f (5.0f,5.0f); glColor3f (0.0f, 1.0f, 0.0f); glVertex2f (25.0f,5.0f); glColor3f (0.0f, 0.0f, 1.0f); glVertex2f (5.0f,25.0f); glEnd (); glBegin (GL_TRIANGLES); glColor3f (1.0f, 1.0f, 0.0f); glVertex2f (26.0f,25.0f); glColor3f (0.0f, 1.0f, 1.0f); glVertex2f (26.0f,5.0f); glColor3f (1.0f, 0.0f, 1.0f); glVertex2f (6.0f,25.0f); glEnd ();&#125;void display(void)&#123; glClear(GL_COLOR_BUFFER_BIT); triangle(); glFlush();&#125;void reshape(int w,int h)&#123; glViewport(0,0,(GLsizei)w, (GLsizei)h); glMatrixMode(GL_PROJECTION); glLoadIdentity(); if(w &lt;= h) gluOrtho2D(0.0,30.0,0.0,30.0*(GLfloat)h/(GLfloat)w); else gluOrtho2D(0.0,30.0*(GLfloat)w/(GLfloat)h,0.0,30.0); glMatrixMode(GL_MODELVIEW);&#125;int main(int argc, char** argv)&#123; glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE); glutInitWindowSize(500, 500); glutInitWindowPosition(100, 100); glutCreateWindow(&quot;OpenGL颜色函数例程&quot;); init(); glutDisplayFunc(display); glutReshapeFunc(reshape); glutMainLoop(); return 0;&#125;]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实验6 简单光照与材质]]></title>
    <url>%2F2020%2F01%2F19%2FCG-Prj6-Light%2F</url>
    <content type="text"><![CDATA[1．实验目的： 通过示范代码1，理解简单光照明模型的基本原理与实现； 通过示范代码2和太阳系示范代码，学习与掌握OpenGL光照与材质设置与使用方法。 2．实验内容：在示范代码1基础上，按以下要求修改： （1） 阅读和修改示范代码中的有关参数，产生不同光照效果，观察显示效果。挑选两张修改的效果图保存为图1-2，与对应修改的代码一起保存至word实验文档中（15分钟）； （2） 将代码中的球体改为圆柱体，将圆柱体的光照效果图存为图3，与对应修改的代码一起保存至word实验文档中（25分钟）； 在示范代码2的基础上，按以下要求完成任务： （3） 阅读和修改示范代码2中的有关参数，产生不同光照效果，观察显示效果。挑选两张修改的效果图保存为图4-5，与对应修改的代码一起保存至word实验文档中（15分钟）； （4）参考太阳系示范代码，该代码显示一个简单的太阳系模型，尝试为其增加光照与材质效果，挑选两张修改的效果图保存为图6-7，与对应修改的代码一起保存至word实验文档中（25分钟）； （5） 整理word实验文档，将其命名为“序号-姓名-Prj6.doc”，电子版提交至雨课堂，A4打印稿下一次课前或实验课前提交。 3．实验原理：Phong光照明模型是由物体表面上一点P反射到视点的光强I为环境光的反射光强Ie、理想漫反射光强Id、和镜面反射光Is的总和，即$$I = I_a k_a + I_p K_d(LN) + I_p K_s(RV)^n$$其中R，V，N为单位矢量；$I_p$为点光源发出的入射光强；$I_a$为环境光的漫反射光强；$K_a$环境光的漫反射系数；$K_d$漫反射系数（ ）取决于表面的材料；$K_s$镜面反射系数（ ）；n幂次，用以模拟反射光的空间分布，表面越光滑，n越大。在用Phong模型进行真实感图形计算时，对物体表面上的每个点P，均需计算光线的反射方向R，再由V计算 。为减少计算量，我们可以作如下假设：a)光源在无穷远处,即光线方向L为常数；b)视点在无穷远处，即视线方向V为常数；c)用 近似 。这里H为L和V的角平分向量， 。在这种简化下，由于对所有的点总共只需计算一次H的值，节省了计算时间。结合RGB颜色模型，Phong光照明模型的最终形式详见教材公式（8.21）。 示范代码1中，光源在无穷远处，光线方向为单位向量L（0.5, 0.5, 0.707）,视点在无穷远处，视线方向V为（0， 0， 1）。 4．示范代码：(1) 示范代码1-球体简单光照模型效果图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include &lt;GL/glut.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;struct Vector&#123; float fx, fy, fz;&#125;;struct Color&#123; float Ir, Ig, Ib;&#125;;float KaIa;float Kd, n;Vector H, light;Color mLight, mColor;void Init()&#123; float mo; Vector eye; mLight.Ir = 0; mLight.Ig = 175; mLight.Ib = 0; KaIa = 100; Kd = 0.7; n = 20; light.fx = 0.50; light.fy = 0.50; light.fz = sqrt(1 - (light.fx*light.fx) - (light.fy*light.fy)); eye.fx = 0; eye.fy = 0; eye.fz = 1; H.fx = light.fx + eye.fx; H.fy = light.fy + eye.fy; H.fz = light.fz + eye.fz; mo = sqrt(H.fx*H.fx + H.fy*H.fy + H.fz*H.fz); H.fx = (H.fx / mo); H.fy = (H.fy / mo); H.fz = (H.fz / mo); H.fx = (H.fx / mo); H.fy = (H.fy / mo); H.fz = (H.fz / mo); glClearColor(1.0, 1.0, 1.0, 0.0); glShadeModel(GL_SMOOTH);&#125;Color Phong(int x0, int y0, int r, int x, int y)&#123; Vector N; float z, alpha, theta, Ks; Ks = 1.0 - Kd; z = sqrt((float)(r*r - (x - x0)*(x - x0) - (y - y0)*(y - y0))); N.fx = (x - x0)*1.0 / r; N.fy = (y - y0)*1.0 / r; N.fz = z * 1.0 / r; theta = N.fx * light.fx + N.fy * light.fy + N.fz * light.fz; if (theta &lt; 0) theta = 0; alpha = H.fx*N.fx + H.fy*N.fy + H.fx*N.fz; if (alpha &lt; 0) alpha = 0; mColor.Ir = KaIa + mLight.Ir*Kd*theta + mLight.Ir*Ks*pow(alpha, n); mColor.Ig = KaIa + mLight.Ig*Kd*theta + mLight.Ig*Ks*pow(alpha, n); mColor.Ib = KaIa + mLight.Ib*Kd*theta + mLight.Ib*Ks*pow(alpha, n); return mColor;&#125;void MidCircle(int x0, int y0, int r)&#123; int x, y, deltax, deltay, d; x = 0; y = r; deltax = 3; deltay = 5 - r - r; d = 1 - r; glBegin(GL_POINTS); &#123; for (int i = -x; i &lt;= x; i++) &#123; mColor = Phong(x0, y0, r, i + x0, y + y0); glColor3ub(mColor.Ir, mColor.Ig, mColor.Ib); glVertex2i(i + x0, y + y0); glColor3ub(mColor.Ir, mColor.Ig, mColor.Ib); glVertex2i(i + x0, -y + y0); &#125; for (int i = -y; i &lt;= y; i++) &#123; mColor = Phong(x0, y0, r, i + x0, x + y0); glColor3ub(mColor.Ir, mColor.Ig, mColor.Ib); glVertex2i(i + x0, x + y0); glColor3ub(mColor.Ir, mColor.Ig, mColor.Ib); glVertex2i(i + x0, -x + y0); &#125; while (x &lt; y) &#123; if (d &lt; 0) &#123; d += deltax; deltax += 2; deltay += 2; x++; &#125; else &#123; d += deltay; deltax += 2; deltay += 4; x++; y--; &#125; for (int i = -x; i &lt;= x; i++) &#123; mColor = Phong(x0, y0, r, i + x0, y + y0); glColor3ub(mColor.Ir, mColor.Ig, mColor.Ib); glVertex2i(i + x0, y + y0); glColor3ub(mColor.Ir, mColor.Ig, mColor.Ib); glVertex2i(i + x0, -y + y0); &#125; for (int i = -y; i &lt;= y; i++) &#123; mColor = Phong(x0, y0, r, i + x0, x + y0); glColor3ub(mColor.Ir, mColor.Ig, mColor.Ib); glVertex2i(i + x0, x + y0); glColor3ub(mColor.Ir, mColor.Ig, mColor.Ib); glVertex2i(i + x0, -x + y0); &#125; &#125; &#125; glEnd();&#125;void myDisplay()&#123; glClear(GL_COLOR_BUFFER_BIT); glColor3f(1.0f, 1.0f, 1.0f); MidCircle(250, 250, 60); glFlush();&#125;void Reshape(int w, int h)&#123; glViewport(0, 0, (GLsizei)w, (GLsizei)h); glMatrixMode(GL_PROJECTION); glLoadIdentity(); gluOrtho2D(0.0, (GLdouble)w, 0.0, (GLdouble)h);&#125;int main(int argc, char *argv[])&#123; glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE); glutInitWindowPosition(100, 100); glutInitWindowSize(640, 480); glutCreateWindow(&quot;Hello World!&quot;); Init(); glutDisplayFunc(myDisplay); glutReshapeFunc(Reshape); glutMainLoop(); return 0;&#125; 程序运行结果： 图1 (2) 示范代码2-OpenGL光照与材质下球体效果图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;GL/glut.h&gt;#include &lt;stdlib.h&gt;// Initialize material property, light source, lighting model, and depth buffer.void init(void)&#123; GLfloat mat_specular[] = &#123; 1.0, 1.0, 1.0, 1.0 &#125;; GLfloat mat_shininess[] = &#123; 50.0 &#125;; GLfloat light_position[] = &#123; 1.0, 1.0, 1.0, 0.0 &#125;; GLfloat white_light[] = &#123; 1.0, 1.0, 1.0, 1.0 &#125;; GLfloat Light_Model_Ambient[] = &#123; 0.2 , 0.2 , 0.2 , 1.0 &#125;; // glClearColor(0.0, 0.0, 0.0, 0.0); glShadeModel(GL_SMOOTH); glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular); glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess); glLightfv(GL_LIGHT0, GL_POSITION, light_position); glLightfv(GL_LIGHT0, GL_DIFFUSE, white_light); glLightfv(GL_LIGHT0, GL_SPECULAR, white_light); glLightModelfv(GL_LIGHT_MODEL_AMBIENT, Light_Model_Ambient); // glEnable(GL_LIGHTING); glEnable(GL_LIGHT0); glEnable(GL_DEPTH_TEST);&#125;void display(void)&#123; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glutSolidSphere (0.5, 20, 16); //glutSolidTeapot(0.5); glFlush();&#125;void reshape(int w, int h)&#123; glViewport(0, 0, (GLsizei)w, (GLsizei)h); glMatrixMode(GL_PROJECTION); glLoadIdentity(); if (w &lt;= h) glOrtho(-1.5, 1.5, -1.5*(GLfloat)h / (GLfloat)w, 1.5*(GLfloat)h / (GLfloat)w, -10.0, 10.0); else glOrtho(-1.5*(GLfloat)w / (GLfloat)h, 1.5*(GLfloat)w / (GLfloat)h, -1.5, 1.5, -10.0, 10.0); glMatrixMode(GL_MODELVIEW); glLoadIdentity();&#125;int main(int argc, char** argv)&#123; glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH); glutInitWindowSize(500, 500); glutInitWindowPosition(100, 100); glutCreateWindow(argv[0]); init(); glutDisplayFunc(display); glutReshapeFunc(reshape); glutMainLoop(); return 0;&#125; 程序运行结果： 图2]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实验5 立方体显示与变换]]></title>
    <url>%2F2020%2F01%2F19%2FCG-Prj5-Cube%2F</url>
    <content type="text"><![CDATA[1．实验目的： 通过示范代码1的立方体实例，理解巩固点的透视投影变换知识； 通过示范代码1的立方体实例，了解OpenGL实体显示的基本原理与方法； 通过示范代码2的立方体实例，学习OpenGL观察变换函数、投影变换函数的设置与使用方法； 2．实验内容：在示范代码1基础上，按以下要求修改： （1） 修改代码，让立方体平移和旋转，产生两点透视和三点透视，将两种透视图结果存为图1-2，与对应修改的代码一起保存至word实验文档中（20分钟）； （2） 参考教材代码7.3.5，将代码中的立方体改为四棱锥，将测试结果存为图3，与对应修改的代码一起保存至word实验文档中（20分钟）； 在示范代码2基础上，按以下要求修改： （3） 学习OpenGL观察变换函数gluLookAt的设置与使用方法，并在代码中修改参数产生两点透视和三点透视，将两种透视图结果存为图4-5，与对应修改的代码一起保存至word实验文档中（20分钟）； （4）学习OpenGL投影变换函数gluPerspective和glOrtho的设置与使用方法，启用gluPerspective函数并修改参数得到不同的透视图6-7，将图和代码保存；启用glOrtho并修改参数得到不同的正交投影图8-9，将图和代码保存（20分钟）； （5） 整理word实验文档，将其命名为“序号-姓名-Prj5.doc”，电子版提交至雨课堂，A4打印稿下一次课前或实验课前提交。 3．实验原理：在OpenGL程序中，观察变换必须出现在模型变换之前，但可以在绘图之前的任何时候执行投影变换和视口变换。 （1）在给定的观察变换之前，应该使用glLoadIdentity函数把当前矩阵设置为单位矩阵。 （2）在载入单位矩阵之后，使用gluLookAt函数指定观察变换。如果程序没有调用gluLookAt()，那么照相机会设定为一个默认的位置和方向。在默认的情况下，照相机位于原点，指向z轴负方向，朝上向量为(0,1,0)。 （3）一般而言，display函数包括：观察变换 + 模型变换 + 绘制图形的函数（如ColorCube）。display会在窗口被移动或者原来先遮住这个窗口的东西被移开时，被重复调用，并经过适当变换，保证绘制的图形是按照希望的方式进行绘制。 （4）在调用gluPerspective设置投影变换之前，在reshape函数中有一些准备工作：视口变换 + 投影变换 + 观察变换 + 模型变换。由于投影变换，视口变换共同决定了场景是如何映射到计算机的屏幕上的，而且它们都与屏幕的宽度、高度密切相关，因此应该放在reshape函数中。reshape函数会在窗口初次创建，移动或改变时被调用。 总结起来，OpenGL中矩阵坐标之间的关系为：物体世界坐标→观察坐标→投影坐标→透视除法→规范化设备坐标→窗口坐标。 （1）用观察变换函数gluLookAt(0.0,0.0,5.0,0.0,0.0,0.0,0.0,1.0,0.0)设置照相机的位置。把照相机放在(0,0,5)，镜头瞄准(0,0,0)，朝上向量定为(0,1,0)，朝上向量为照相机指定了一个唯一的方向。如果没有调用gluLookAt函数，照相机就设定一个默认的位置和方向，如上所述。glLoadIdentity函数把当前矩阵设置为单位矩阵。 （2）使用模型变换的目的是设置模型的位置和方向。 （3）投影变换，指定投影变换类似于为照相机选择镜头，可以认为这种变换的目的是确定视野，并因此确定哪些物体位于视野之内以及它们能够被看到的程度。除了考虑视野之外，投影变换确定物体如何投影到屏幕上，OpenGL提供了两种基本类型的投影：(i)透视投影：远大近小；(ii)正投影：不影响相对大小，一般用于工程当中。 （4）视口变换。视口变换指定一个图像在屏幕上所占的区域，可参考OpenGL的glViewport视口变换函数详解。 （5）绘制场景。 4．示范代码：(1) 示范代码1-通过透视投影变换计算投影点来显示立方体投影图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162// Projection.cpp : Defines the entry point for the console application.//#include &lt;GL/glut.h&gt;#include &lt;stdio.h&gt;#include &lt;math.h&gt;struct Matrix&#123; double p[4][4]; Matrix(int val = 1);//默认val =1 为单位阵，val =0 为零阵&#125;;double lx = 0, ly = 0, lz = -1;double phi = 0;double d = 5;Matrix mT, mR, mP, mTemp, mA;int flag = 1; // display cube with wireframe 1 or face mode 2GLfloat vertices0[8][3] = &#123; &#123;-1.0, -1.0, 1.0&#125;,&#123;-1.0, 1.0, 1.0&#125;,&#123;1.0,1.0, 1.0&#125;,&#123;1.0,-1.0,1.0&#125;, &#123;-1.0,-1.0,-1.0&#125;, &#123;-1.0,1.0,-1.0&#125;,&#123;1.0,1.0,-1.0&#125;, &#123;1.0,-1.0,-1.0&#125; &#125;;GLfloat vertices1[8][2] = &#123; &#123;-1.0,-1.0&#125;,&#123;1.0,-1.0&#125;,&#123;1.0,1.0&#125;,&#123;-1.0,1.0&#125;,&#123;-1.0,-1.0&#125;,&#123;1.0,-1.0&#125;,&#123;1.0,1.0&#125;,&#123;-1.0,1.0&#125; &#125;;GLfloat colors[6][3] = &#123; &#123;1.0,1.0,1.0&#125;, &#123;1.0,0.0,0.0&#125;, &#123;1.0,1.0,0.0&#125;,&#123;0.0,0.0,1.0&#125;, &#123;1.0,0.0,1.0&#125;, &#123;0.0,1.0,1.0&#125; &#125;;Matrix::Matrix(int val)&#123; for (long i = 0; i &lt; 4; i++) &#123; for (long j = 0; j &lt; 4; j++) &#123; if (i == j) p[i][j] = val; else p[i][j] = 0; &#125; &#125;&#125;Matrix Multiply(Matrix&amp; m1, Matrix&amp; m2)&#123; Matrix m(0); for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 4; j++) for (int k = 0; k &lt; 4; k++) m.p[i][j] += (m1.p[i][k] * m2.p[k][j]); return m;&#125;void InitParameter()//初始化参数&#123; mT.p[3][0] = lx; mT.p[3][1] = ly; mT.p[3][2] = lz; mR.p[0][0] = cos(phi); mR.p[0][2] = -sin(phi); mR.p[2][0] = sin(phi); mR.p[2][2] = cos(phi); mP.p[2][2] = 0; mP.p[2][3] = -1 / d; mTemp = Multiply(mT, mR); mA = Multiply(mTemp, mP);&#125;void Project(int num, GLfloat vertices0[][3], GLfloat vertices1[][2])//透视变换&#123; for (int i = 0; i &lt; num; i++) &#123; GLfloat ptH[4] = &#123; vertices0[i][0], vertices0[i][1], vertices0[i][2], 1 &#125;;//齐次坐标 GLfloat res[4] = &#123;0, 0, 0, 0&#125;; for (int j = 0; j &lt; 4; j++) for (int k = 0; k &lt; 4; k++) res[j] += (ptH[k] * mA.p[k][j]); vertices1[i][0] = res[0] / res[3]; vertices1[i][1] = res[1] / res[3]; &#125;&#125;void Polygon(int clr, int a, int b, int c, int d)&#123; glColor3fv(colors[clr]); if (flag == 1) glBegin(GL_LINE_LOOP); else glBegin(GL_POLYGON); glVertex2fv(vertices1[a]); glVertex2fv(vertices1[b]); glVertex2fv(vertices1[c]); glVertex2fv(vertices1[d]); glEnd();&#125;void ColorCube(void)&#123; Polygon(0, 0, 3, 2, 1); Polygon(1, 2, 3, 7, 6); Polygon(2, 0, 4, 7, 3); Polygon(3, 1, 2, 6, 5); Polygon(4, 4, 5, 6, 7); Polygon(5, 0, 1, 5, 4); //Polygon(0, 0, 3, 2, 1);&#125;void myDisplay()&#123; glClear(GL_COLOR_BUFFER_BIT); glColor3f(1.0f, 0.0f, 0.0f); InitParameter(); Project(8, vertices0, vertices1); ColorCube(); glutSwapBuffers();&#125;void Init()&#123; glClearColor(0.0, 0.0, 0.0, 0.0); glShadeModel(GL_FLAT); printf(&quot;Hello Cube!\n&quot;);&#125;void Reshape(int w, int h)&#123; glViewport(0, 0, (GLsizei)w, (GLsizei)h); glMatrixMode(GL_PROJECTION); glLoadIdentity(); glOrtho(-5, 5, -5, 5, -10, 10);&#125;void keyboard(unsigned char key, int x, int y)&#123; switch (key) &#123; case &apos;1&apos;: flag = 1; glutPostRedisplay(); break; case &apos;2&apos;: flag = 2; glutPostRedisplay(); break; default: break; &#125;&#125;int main(int argc, char *argv[])&#123; glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE); glutInitWindowPosition(100, 100); glutInitWindowSize(600, 600); glutCreateWindow(&quot;Hello World!&quot;); glutDisplayFunc(myDisplay); glutReshapeFunc(Reshape); glutKeyboardFunc(keyboard); glutMainLoop(); return 0;&#125; 程序运行结果： 图1 (2) 示范代码2-通过OpenGL观察变换和投影变换函数来显示立方体投影图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;gl/glut.h&gt; int flag = 1;GLfloat rquad = 0;GLfloat vertices[8][3] = &#123; &#123;-1.0, -1.0, 1.0&#125;,&#123;-1.0, 1.0, 1.0&#125;,&#123;1.0,1.0, 1.0&#125;,&#123;1.0,-1.0,1.0&#125;,&#123;-1.0,-1.0,-1.0&#125;, &#123;-1.0,1.0,-1.0&#125;,&#123;1.0,1.0,-1.0&#125;, &#123;1.0,-1.0,-1.0&#125; &#125;;GLfloat colors[6][3] = &#123; &#123;1.0,1.0,1.0&#125;, &#123;1.0,0.0,0.0&#125;, &#123;1.0,1.0,0.0&#125;,&#123;0.0,0.0,1.0&#125;, &#123;1.0,0.0,1.0&#125;, &#123;0.0,1.0,1.0&#125; &#125;;void InitGL(GLvoid)&#123; glShadeModel(GL_SMOOTH); glClearColor(0.0, 0.0, 0.0, 0.0); glClearDepth(1.0f); glEnable(GL_DEPTH_TEST); glDepthFunc(GL_LEQUAL); glEnable(GL_COLOR_MATERIAL); glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);&#125;void Polygon(int clr, int a, int b, int c, int d)&#123; glColor3fv(colors[clr]); if (flag == 1) glBegin(GL_LINE_LOOP); else glBegin(GL_POLYGON); glVertex3fv(vertices[a]); glVertex3fv(vertices[b]); glVertex3fv(vertices[c]); glVertex3fv(vertices[d]); glEnd();&#125;void ColorCube(void)&#123; Polygon(0, 0, 3, 2, 1); Polygon(1, 2, 3, 7, 6); Polygon(2, 0, 4, 7, 3); Polygon(3, 1, 2, 6, 5); Polygon(4, 4, 5, 6, 7); Polygon(5, 0, 1, 5, 4);&#125;void display(void)&#123; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glLoadIdentity(); glPushMatrix(); gluLookAt(0, 0, 5, 0, 0, 0, 0, 1, 0); glTranslatef(0.0f, 0.0f, -1.0f); //平移 //glRotatef(rquad, 1.0f, 0.0f, 0.0f); //旋转一个角度 ColorCube(); glPopMatrix(); rquad -= 0.15f; //修改立方体的旋转角度 glutSwapBuffers();&#125;void reshape(int width, int height)&#123; if (height == 0) height = 1; glViewport(0, 0, width, height); glMatrixMode(GL_PROJECTION); glLoadIdentity(); //gluPerspective(90.0f, (GLfloat)width / (GLfloat)height, 0.0f, 100.0f); gluPerspective(90.0f, (GLfloat)width / (GLfloat)height, 0.1f, 100.0f); //if (width &lt;= height) // glOrtho(-2.0, 2.0, -2.0*(GLfloat)height / (GLfloat)width, 2.0*(GLfloat)height / (GLfloat)width, 1.0, 20.0); //else // glOrtho(-2.0*(GLfloat)width / (GLfloat)height, 2.0*(GLfloat)width / (GLfloat)height, -2.0, 2.0, 1.0, 20.0); glMatrixMode(GL_MODELVIEW); glLoadIdentity();&#125;void keyboard(unsigned char key, int x, int y)&#123; switch (key) &#123; case &apos;1&apos;: flag = 1; glutPostRedisplay(); break; case &apos;2&apos;: flag = 2; glutPostRedisplay(); break; default: break; &#125;&#125;int main(int argc, char** argv)&#123; glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE); glutInitWindowSize(600, 600); glutCreateWindow(&quot;Hello Cube&quot;); InitGL(); glutDisplayFunc(display); glutReshapeFunc(reshape); glutIdleFunc(display); glutKeyboardFunc(keyboard); glutMainLoop(); return 0;&#125; 程序运行结果： 图2 5．实验思考在示范代码2中，若将gluPerspective(90.0f, (GLfloat)width / (GLfloat)height, 0.1f, 100.0f)代码改为如下： gluPerspective(90.0f, (GLfloat)width / (GLfloat)height, 0.0f, 100.0f)， 点击按键1和2，切换显示方式，观察下显示效果有何不同，试解释原因。]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实验4 二维几何变换]]></title>
    <url>%2F2020%2F01%2F19%2FCG-Prj4-2D-Transformation%2F</url>
    <content type="text"><![CDATA[1．实验目的： 巩固对二维几何变换的认识与理解； 学习OpenGL平移、旋转、缩放变换函数及其使用方法； 学习基本图形变换与复合图形变换的方法； 综合运用上述函数，设计复杂图形。 2．实验内容：根据示范代码1，使用OpenGL平移、旋转、缩放变换函数来改写代码实现所要求的功能。示范代码1的代码运行结果为图1。 （1） 使用glTranslatef()函数，实现图形平移，并结合glTranslatef()函数的不同参数输入，实现x，y和z方向的平移，将测试结果存为图1-3，与对应修改的平移函数代码一起保存至word实验文档中（20分钟）； （2） 使用glRotatef()函数，实现图形旋转，并结合glRotatef()函数的不同参数输入，实现x，y和z方向的旋转，将测试结果存为图4-6，与对应修改的旋转函数代码一起保存至word实验文档中（20分钟）； （3） 使用glScalef()函数，实现图形缩放，并结合glScalef()函数的不同参数输入，实现x，y和z方向的旋转，将测试结果存为图7-9，与对应修改的缩放函数代码一起保存至word实验文档中（20分钟）； （4）示范代码2，代码运行结果为图2，请参考它绘制如图3所示的图形，将绘图结果与代码保存至word实验文档中（30分钟）； （5） 整理word实验文档，将其命名为“序号-姓名-Prj4.doc”，电子版提交至雨课堂，A4打印稿下一次课前或实验课前提交。 3．实验原理：（1）OpenGL下的几何变换在OpenGL的核心库中，每一种几何变换都有一个独立的函数，所有变换都在三维空间中定义。平移矩阵构造函数为glTranslate&lt;f,d&gt;(tx, ty, tz)，作用是把当前矩阵和一个表示移动物体的矩阵相乘。tx、ty、tz指定这个移动物体的矩阵，它们可以是任意的实数值，后缀为f（单精度浮点float）或d（双精度浮点double），对于二维应用来说，tz=0.0。旋转矩阵构造函数为glRotate&lt;f,d&gt;(theta, vx, vy, vz)，作用是把当前矩阵和一个表示旋转物体的矩阵相乘。theta，vx，vy，vz指定这个旋转物体的矩阵，物体将围绕(0,0,0)到(x,y,z)的直线以逆时针旋转，参数theta表示旋转的角度。向量v=(vx,vy,vz)的分量可以是任意的实数值，该向量用于定义通过坐标原点的旋转轴的方向，后缀为f（单精度浮点float）或d（双精度浮点double），对于二维旋转来说，vx=0.0，vy=0.0，vz=1.0。缩放矩阵构造函数为glScale&lt;f,d&gt;(sx, sy, sz)，作用是把当前矩阵和一个表示缩放物体的矩阵相乘。sx，sy，sz指定这个缩放物体的矩阵，分别表示在x，y，z方向上的缩放比例，它们可以是任意的实数值，当缩放参数为负值时，该函数为反射矩阵，缩放相对于原点进行，后缀为f（单精度浮点float）或d（双精度浮点double）。注意这里都是说“把当前矩阵和一个表示移动&lt;旋转, 缩放&gt;物体的矩阵相乘”，而不是直接说“这个函数就是旋转”或者“这个函数就是移动”，这是有原因的，马上就会讲到。假设当前矩阵为单位矩阵，然后先乘以一个表示旋转的矩阵R，再乘以一个表示移动的矩阵T，最后得到的矩阵再乘上每一个顶点的坐标矩阵v。那么，经过变换得到的顶点坐标就是((RT)v)。由于矩阵乘法满足结合率，((RT)v) = R(Tv))，换句话说，实际上是先进行移动，然后进行旋转。即：实际变换的顺序与代码中写的顺序是相反的。由于“先移动后旋转”和“先旋转后移动”得到的结果很可能不同，初学的时候需要特别注意这一点。 （2）OpenGL下的各种变换简介我们生活在一个三维的世界，如果要观察一个物体，我们可以：① 从不同的位置去观察它（人运动，选定某个位置去看）。（视图变换）② 移动或者旋转它，当然了，如果它只是计算机里面的物体，我们还可以放大或缩小它（物体运动，让人看它的不同部分）。（模型变换）③ 如果把物体画下来，我们可以选择是否需要一种“近大远小”的透视效果。另外，我们可能只希望看到物体的一部分，而不是全部（指定看的范围）。（投影变换）④ 我们可能希望把整个看到的图形画下来，但它只占据纸张的一部分，而不是全部（指定在显示器窗口的那个位置显示）。（视口变换）这些，都可以在OpenGL中实现。从“相对移动”的观点来看，改变观察点的位置与方向和改变物体本身的位置与方向具有等效性。在OpenGL中，实现这两种功能甚至使用的是同样的函数。由于模型和视图的变换都通过矩阵运算来实现，在进行变换前，应先设置当前操作的矩阵为“模型视图矩阵”。设置的方法是以GL_MODELVIEW为参数调用glMatrixMode函数，例如：1glMatrixMode(GL_MODELVIEW); 该语句指定一个4×4的建模矩阵作为当前矩阵。通常，我们需要在进行变换前把当前矩阵设置为单位矩阵。把当前矩阵设置为单位矩阵的函数为：1glLoadIdentity(); 我们在进行矩阵操作时，有可能需要先保存某个矩阵，过一段时间再恢复它。当我们需要保存时，调用glPushMatrix()函数，它相当于把当前矩阵压入堆栈。当需要恢复最近一次的保存时，调用glPopMatrix()函数，它相当于从堆栈栈顶弹出一个矩阵为当前矩阵。OpenGL规定堆栈至少可以容纳32个矩阵，某些OpenGL实现中，堆栈的容量实际上超过了32个。因此不必过于担心矩阵的容量问题。通常，用这种先保存后恢复的措施，比先变换再逆变换要更方便、更快速。注意：模型视图矩阵和投影矩阵都有相应的堆栈。使用glMatrixMode来指定当前操作的究竟是模型视图矩阵还是投影矩阵。 (3) 某图形绕任意点(cx, cy)旋转 $\alpha$ 角。1234567清屏glMatrixMode(GL_MODELVIEW); //设置矩阵模式为模型变换模式，表示在世界坐标系下glLoadIdentity(); //将当前矩阵设置为单位矩阵glTranslatef(cx,cy,0); //平移回去 glRotatef(alpha,0,0,1); //绕原点旋转ALPHA角度 glTranslatef(-cx,-cy,0); //平移回原点drawSquare(); 图形绕任意点缩放方法的代码只需把旋转函数换为缩放函数即可，不再赘述。 4．示范代码：示范代码1123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;GL/glut.h&gt;void init (void)&#123; glClearColor (1.0, 1.0, 1.0, 0.0); glMatrixMode (GL_PROJECTION); gluOrtho2D (-5.0, 5.0, -5.0, 5.0); //设置显示的范围是X:-5.0~5.0, Y:-5.0~5.0 glMatrixMode (GL_MODELVIEW);&#125;void drawSquare(void) //绘制中心在原点，边长为2的正方形&#123; glBegin (GL_POLYGON); //顶点指定需要按逆时针方向 glVertex2f (-1.0f,-1.0f); //左下点 glVertex2f (1.0f,-1.0f); //右下点 glVertex2f (1.0f, 1.0f); //右上点 glVertex2f (-1.0f,1.0f); //左上点 glEnd ( );&#125;void myDraw (void)&#123; glClear (GL_COLOR_BUFFER_BIT); //清空 glLoadIdentity(); //将当前矩阵设为单位矩阵 glColor3f (1.0, 0.0, 0.0); drawSquare(); //上面红色矩形 glFlush ( );&#125;void main (int argc, char** argv)&#123; glutInit (&amp;argc, argv); glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB); glutInitWindowPosition (0, 0); glutInitWindowSize (600, 600); glutCreateWindow (&quot;几何变换示例1&quot;); init(); glutDisplayFunc (myDraw); glutMainLoop(); &#125; 程序运行结果： 图1 示范代码212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;GL/glut.h&gt;void init (void)&#123; glClearColor (1.0, 1.0, 1.0, 0.0); glMatrixMode (GL_PROJECTION); gluOrtho2D (-5.0, 5.0, -5.0, 5.0); //设置显示的范围是X:-5.0~5.0, Y:-5.0~5.0 glMatrixMode (GL_MODELVIEW);&#125;void drawSquare(void) //绘制中心在原点，边长为2的正方形&#123; glBegin (GL_POLYGON); //顶点指定需要按逆时针方向 glVertex2f (-1.0f,-1.0f); //左下点 glVertex2f (1.0f,-1.0f); //右下点 glVertex2f (1.0f, 1.0f); //右上点 glVertex2f (-1.0f,1.0f); //左上点 glEnd ( );&#125;void myDraw (void)&#123; glClear (GL_COLOR_BUFFER_BIT); //清空 glLoadIdentity(); //将当前矩阵设为单位矩阵 glPushMatrix(); glTranslatef(0.0f,2.0f,0.0f); glScalef(3.0,0.5,1.0); glColor3f (1.0, 0.0, 0.0); drawSquare(); //上面红色矩形 glPopMatrix(); glPushMatrix(); glTranslatef(-3.0,0.0,0.0); glPushMatrix(); glRotatef(45.0,0.0,0.0,1.0); glColor3f (0.0, 1.0, 0.0); drawSquare(); //中间左菱形 glPopMatrix(); glTranslatef(3.0,0.0,0.0); glPushMatrix(); glRotatef(45.0,0.0,0.0,1.0); glColor3f (0.0, 0.7, 0.0); drawSquare(); //中间中菱形 glPopMatrix(); glTranslatef(3.0,0.0,0.0); glPushMatrix(); glRotatef(45.0,0.0,0.0,1.0); glColor3f (0.0, 0.4, 0.0); drawSquare(); //中间右菱形 glPopMatrix(); glPopMatrix(); glTranslatef(0.0,-3.0,0.0); glScalef(4.0,1.5,1.0); glColor3f (0.0, 0.0, 1.0); drawSquare(); //下面蓝色矩形 glFlush ( );&#125;void main (int argc, char** argv)&#123; glutInit (&amp;argc, argv); glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB); glutInitWindowPosition (0, 0); glutInitWindowSize (600, 600); glutCreateWindow (&quot;几何变换示例2&quot;); init(); glutDisplayFunc (myDraw); glutMainLoop(); &#125; 程序运行结果： 图2 图3 5．实验思考在绕任意点旋转时，若将相关代码改为如下：1234567清屏glMatrixMode(GL_MODELVIEW); //设置矩阵模式为模型变换模式，表示在世界坐标系下glLoadIdentity(); //将当前矩阵设置为单位矩阵glTranslatef(-cx,-cy,0); //平移回去 glRotatef(theta,0,0,1); //绕原点旋转ALPHA角度 glTranslatef(cx,cy,0); //平移回原点drawSquare(); 图形将变成怎样？试解释原因。]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实验3 直线裁剪算法]]></title>
    <url>%2F2020%2F01%2F19%2FCG-Prj3-Clipping%2F</url>
    <content type="text"><![CDATA[1．实验目的： 理解直线裁剪的基本原理； 验证直线的编码裁剪算法，参考网络资料实现梁友栋-Barsky裁剪算法； 了解与掌握OpenGL鼠标操作。 2．实验内容：本次实验主要结合鼠标画线程序来验证编码裁剪算法和梁友栋-Barsky裁剪算法，具体步骤如下： （1） 阅读学习所给的编码裁剪示范代码，了解程序使用方法，并结合三种不同类型直线对其进行裁剪测试，将测试结果存为图1-3，保存至word实验文档中（30分钟）； （2） 为示范代码增加梁友栋-Barsky裁剪算法，并通过键盘按键“L”来控制，即按键盘“L”键时，用梁友栋-Barsky算法裁剪程序窗口内的直线。同样测试三种不同类型的直线，将测试结果存为图4-6，，保存至word实验文档中（60分钟）； （3） 整理图1-6，并增加程序代码合并到一个word文档，将其命名为“序号-姓名-Prj2.doc”，电子版提交至雨课堂，A4打印稿下一次课前或实验课前提交。 3．实验原理：示范代码中编码裁剪算法原理参见教材裁剪内容，有关鼠标操作知识请参考OpenGL编程 基础篇（四）与鼠标的交互。 4．实验代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195#include &lt;GL/glut.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define LEFT_EDGE 1#define RIGHT_EDGE 2#define BOTTOM_EDGE 4#define TOP_EDGE 8struct Rectangle&#123; float xmin, xmax, ymin, ymax;&#125;;Rectangle rect;int x0, y0, x1, y1;bool bDrawLine = true;int width = 640, height = 480;void LineGL(int x0, int y0, int x1, int y1)&#123; glBegin(GL_LINES); glColor3f(1.0f, 0.0f, 0.0f); glVertex2f(x0, y0); glColor3f(1.0f, 0.0f, 0.0f); glVertex2f(x1, y1); glEnd();&#125;//求p点的编码int CompCode(int x, int y, Rectangle rect)&#123; int code = 0x00; if (y &lt; rect.ymin) code = code | 4;//即为1000 if (y &gt; rect.ymax) code = code | 8;//即为0100 if (x &gt; rect.xmax) code = code | 2; if (x &lt; rect.xmin) code = code | 1; return code;&#125;bool cohensutherlandlineclip(Rectangle rect, int &amp;x0, int &amp; y0, int &amp;x1, int &amp;y1)&#123; bool accept, done; float x, y; accept = false; done = false; int code0, code1, codeout; code0 = CompCode(x0, y0, rect); code1 = CompCode(x1, y1, rect); do &#123; if (!(code0 | code1)) &#123; accept = true; done = true; &#125; else if (code0 &amp; code1) done = true; else &#123; if (code0 != 0) codeout = code0; else codeout = code1; if (codeout&amp;LEFT_EDGE) &#123; y = y0 + (y1 - y0)*(rect.xmin - x0) / (x1 - x0); x = (float)rect.xmin; &#125; else if (codeout&amp;RIGHT_EDGE) &#123; y = y0 + (y1 - y0)*(rect.xmax - x0) / (x1 - x0); x = (float)rect.xmax; &#125; else if (codeout&amp;BOTTOM_EDGE) &#123; x = x0 + (x1 - x0)*(rect.ymin - y0) / (y1 - y0); y = (float)rect.ymin; &#125; else if (codeout&amp;TOP_EDGE) &#123; x = x0 + (x1 - x0)*(rect.ymax - y0) / (y1 - y0); y = (float)rect.ymax; &#125; if (codeout == code0) &#123; x0 = x; y0 = y; code0 = CompCode(x0, y0, rect); &#125; else &#123; x1 = x; y1 = y; code1 = CompCode(x1, y1, rect); &#125; &#125; &#125; while (!done); return accept;&#125;void myDisplay()&#123; glClear(GL_COLOR_BUFFER_BIT); glColor3f(1.0f, 1.0f, 0.0f); glRectf(rect.xmin, rect.ymin, rect.xmax, rect.ymax); if (bDrawLine) LineGL(x0, y0, x1, y1); glFlush();&#125;void Init()&#123; glClearColor(0.0, 0.0, 0.0, 0.0); glShadeModel(GL_FLAT); rect.xmin = 100; //窗口的大小 rect.xmax = 300; rect.ymin = 100; rect.ymax = 300; x0 = 300, y0 = 50, x1 = 0, y1 = 450;//裁剪前的直线端点 printf(&quot;Press key &apos;c&apos; to Clip!\n&quot;); printf(&quot;Please Click left button of mouse to input the points of Line!!\n&quot;);&#125;void Reshape(int w, int h)&#123; glViewport(0, 0, (GLsizei)w, (GLsizei)h); glMatrixMode(GL_PROJECTION); glLoadIdentity(); gluOrtho2D(0.0, (GLdouble)w, 0.0, (GLdouble)h);&#125;void keyboard(unsigned char key, int x, int y)&#123; switch (key) &#123; case &apos;c&apos;: bDrawLine = cohensutherlandlineclip(rect, x0, y0, x1, y1); glutPostRedisplay();//重画 break; case &apos;x&apos;: exit(0); break; default: break; &#125;&#125;void mouse(int button, int state, int x, int y)&#123; switch (button) &#123; case GLUT_LEFT_BUTTON: if (state == GLUT_DOWN) &#123; if(bDrawLine) &#123; x0 = x; y0 = height - y; bDrawLine = false; glutPostRedisplay();// &#125; else &#123; x1 = x; y1 = height - y; bDrawLine = true; glutPostRedisplay();// &#125; &#125; break; default: break; &#125;&#125;int main(int argc, char *argv[])&#123; glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE); glutInitWindowPosition(100, 100); glutInitWindowSize(width, height); glutCreateWindow(&quot;Hello World!&quot;); Init(); glutDisplayFunc(myDisplay); glutReshapeFunc(Reshape); glutKeyboardFunc(keyboard); glutMouseFunc(mouse); glutMainLoop(); return 0;&#125; 5．实验思考实验示范代码的第162行：1y0 = height - y; 请解释这行代码的含义和作用。]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实验2 基本图元光栅化]]></title>
    <url>%2F2020%2F01%2F19%2FCG-Prj2-Primitive%2F</url>
    <content type="text"><![CDATA[1．实验目的： 理解基本图形元素光栅化的基本原理； 掌握基本图形元素光栅化方法，如中点方法，Bresenham方法； 利用OpenGL实现基本图形元素的光栅化算法。 2．实验内容：（1） 阅读学习所给的直线光栅化的DDA算法示范代码，将其彻底弄懂，根据实验思考题找出其中的错误；同时能在计算机上编译运行，输出正确结果，指出错误并截图保存为图1至word实验文档（30分钟）； （2） 在示范程序的基础上，根据程序所留接口，增加中点线算法，并给出若干条测试直线实例，，截图保存为图2至word实验文档（30分钟）； （3） 为示范程序增加中点圆绘制算法，同时增加键盘按键控制（数字按键3），并给出若干个测试圆的实例，截图保存为图3至word实验文档（30分钟）； （4） 整理图1-3，并增加程序代码合并到一个word文档，将其命名为“序号-姓名-Prj2.doc”，电子版提交至雨课堂，A4打印稿下一次课前或实验课前提交。 3．实验原理：示范代码原理参见教材直线光栅化一节中的DDA算法。下面介绍下OpenGL画线的一些基础知识和glutReshapeFunc()函数。 （1）数学上的直线没有宽度，但OpenGL的直线则是有宽度的。同时，OpenGL的直线必须是有限长度，而不是像数学概念那样是无限的。可以认为，OpenGL的“直线”概念与数学上的“线段”接近，它可以由两个端点来确定。这里的线由一系列顶点顺次连结而成，有闭合和不闭合两种。 前面的实验已经知道如何绘“点”，那么OpenGL是如何知道拿这些顶点来做什么呢？是一个一个的画出来，还是连成线？或者构成一个多边形？或是做其它事情呢？为了解决这一问题，OpenGL要求：指定顶点的命令必须包含在glBegin函数之后，glEnd函数之前（否则指定的顶点将被忽略），并由glBegin来指明如何使用这些点。 例如：1234567glBegin(GL_POINTS); glVertex2f(0.0f, 0.0f); glVertex2f(0.5f, 0.0f);glEnd(); 则这两个点将分别被画出来。如果将GL_POINTS替换成GL_LINES，则两个点将被认为是直线的两个端点，OpenGL将会画出一条直线。还可以指定更多的顶点，然后画出更复杂的图形。另一方面，glBegin支持的方式除了GL_POINTS和GL_LINES，还有GL_LINE_STRIP，GL_LINE_LOOP，GL_TRIANGLES，GL_TRIANGLE_STRIP，GL_TRIANGLE_FAN等，每种方式的大致效果如图A.2所示： 图A.2 OpenGL几何图元类型 （2）首次打开窗口、移动窗口和改变窗口大小时，窗口系统都将发送一个事件，以通知程序员。如果使用的是GLUT，通知将自动完成，并调用向glutReshapeFunc()注册的函数。该函数必须完成下列工作： 重新建立用作新渲染画布的矩形区域； 定义绘制物体时使用的坐标系。 如：12345678910111213void Reshape(int w, int h)&#123;glViewport(0, 0, (GLsizei) w, (GLsizei) h);glMatrixMode(GL_PROJECTION);glLoadIdentity();gluOrtho2D(0.0, (GLdouble) w, 0.0, (GLdouble) h);&#125; 在GLUT内部，将给该函数传递两个参数：窗口被移动或修改大小后的宽度和高度，单位为像素。glViewport()调整像素矩形，用于绘制整个窗口。接下来三个函数调整绘图坐标系，使左下角位置为（0， 0），右上角为（w, h）。 （3） 键盘输入 当你按下一个键后，GLUT提供了两个函数为这个键盘消息注册回调。第一个是glutKeyboardFunc，用来处理普通按键，如字母，数字，和其他可以用ASCII代码表示的键；另一个是glutSpecialFunc，用来处理特殊按键，如$F_i$，方向键，Home，End键等。 glutKeyboardFunc函数原型如下：void glutKeyboardFunc(void(*func)(unsigned char key,int x,int y));参数：func: 处理普通按键消息的函数的名称。如果传递NULL，则表示GLUT忽略普通按键消息。这个作为glutKeyboardFunc函数参数的函数需要有三个形参：第一个表示按下的键的ASCII码，其余两个提供了当键按下时当前的鼠标位置。鼠标位置是相对于当前客户窗口的左上角而言的。 glutSpecialFunc函数请参考https://blog.csdn.net/xie_zi/article/details/1911891。 4．实验代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;GL/glut.h&gt;int flag = 0;void LineDDA(int x0,int y0,int x1,int y1/*,int color*/)&#123; int x, dy, dx, y; float m; dx=x1-x0; dy=y1-y0; m=dy/dx; y=y0; glColor3f (1.0f, 1.0f, 0.0f); glPointSize(1); for(x=x0;x&lt;=x1; x++) &#123; glBegin (GL_POINTS); glVertex2i (x, (int)(y+0.5)); glEnd (); y+=m; &#125; &#125;void LineMidPoint(int x0, int y0, int x1, int y1)&#123; //请在这里填写你的代码&#125;void myDisplay(void)&#123; glClear(GL_COLOR_BUFFER_BIT); glColor3f (1.0f, 0.0f, 0.0f); glRectf(25.0, 25.0, 75.0, 75.0); glPointSize(5); glBegin (GL_POINTS); glColor3f (0.0f, 1.0f, 0.0f); glVertex2f (0.0f, 0.0f); glEnd (); glBegin (GL_LINES); glColor3f (1.0f, 0.0f, 0.0f); glVertex2f (100.0f, 0.0f); glColor3f (0.0f, 1.0f, 0.0f); glVertex2f (180.0f, 240.0f); glEnd (); if(flag == 1) LineDDA(0, 0, 200, 300); //if (flag == 2) //LineMidPoint(...); glFlush();&#125;void Init()&#123; glClearColor(0.0, 0.0, 0.0, 0.0); glShadeModel(GL_FLAT);&#125;void Reshape(int w, int h)&#123; glViewport(0, 0, (GLsizei) w, (GLsizei) h); glMatrixMode(GL_PROJECTION); glLoadIdentity(); gluOrtho2D(0.0, (GLdouble) w, 0.0, (GLdouble) h);&#125;void keyboard(unsigned char key, int x, int y)&#123; switch (key) &#123; case &apos;1&apos;://DDA Line flag = 1; break; case &apos;2&apos;: // MidPoint Line //请在这里填写你的代码 break; default: break; &#125; glutPostRedisplay();//重画&#125;int main(int argc, char *argv[])&#123; glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE); glutInitWindowPosition(100, 100); glutInitWindowSize(400, 400); glutCreateWindow(&quot;Hello World!&quot;); Init(); glutDisplayFunc(myDisplay); glutReshapeFunc(Reshape); glutKeyboardFunc(keyboard); glutMainLoop(); return 0;&#125; 注： glShadeModel选择平坦或光滑渐变模式。GL_SMOOTH为缺省值，为光滑渐变模式，GL_FLAT为平坦渐变模式。 5．实验思考示范代码有个小错误，能否指出并改正？请将结果写入实验报告。]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实验1 OpenGL初识]]></title>
    <url>%2F2020%2F01%2F19%2FCG-Prj1-Beginning%2F</url>
    <content type="text"><![CDATA[1．实验目的： 熟悉编程环境；了解光栅图形显示器的特点； 了解计算机绘图的特点； 利用VC+OpenGL作为开发平台设计程序，以能够在屏幕上生成任意一个像素点为本实验的结束。 2．实验内容：（0） 实验预备知识；Windows下的OpenGL编程步骤简单介绍详见课程实验教学博客－实验0 安装GLUT包与创建工程（40分钟）： https://blog.csdn.net/wpxu08/article/details/70208353 （1） 了解和使用VC的开发环境，理解简单的OpenGL程序结构（20分钟）； （2） 掌握OpenGL提供的基本图形函数，尤其是生成点的函数（20分钟）； （3） 撰写实验报告，增加程序代码合并到一个word文档，将其命名为“序号-姓名-Prj1.doc”，电子版提交至雨课堂，A4打印稿下一次课前或实验课前提交（20分钟）。 3．实验原理：1）基本语法 常用的程序设计语言，如C、C++、Pascal、Fortran和Java等，都支持OpenGL的开发。这里只讨论C版本下OpenGL的语法。 OpenGL基本函数均使用gl作为函数名的前缀，如glClearColor()；实用函数则使用glu作为函数名的前缀，如gluSphere()。OpenGL基本常量的名字以GL_开头，如GL_LINE_LOOP；实用常量的名字以GLU_开头，如GLU_FILL。一些函数如glColor*()（定义颜色值），函数名后可以接不同的后缀以支持不同的数据类型和格式。如glColor3b(…)、glColor3d(…)、glColor3f(…)和glColor3bv(…)等，这几个函数在功能上是相似的，只是适用于不同的数据类型和格式，其中3表示该函数带有三个参数，b、d、f分别表示参数的类型是字节型、双精度浮点型和单精度浮点型，v则表示这些参数是以向量形式出现的。 为便于移植，OpenGL定义了一些自己的数据类型，如GLfloat,GLvoid。它们其实就是C中的float和void。在gl.h文件中可以看到以下定义： …… typedef float GLfloat; typedef void GLvoid; …… 一些基本的数据类型都有类似的定义项。 （2）程序的基本结构 OpenGL程序的基本结构可分为三个部分： 第一部分是初始化部分。主要是设置一些OpenGL的状态开关，如颜色模式(RGBA或Alpha)的选择，是否作光照处理(若有的话，还需设置光源的特性)，深度检测，裁剪等等。这些状态一般都用函数glEnable(…), glDisable(…)来设置，…表示特定的状态。 第二部分设置观察坐标系下的取景模式和取景框位置大小。主要利用了三个函数： 函数void glViewport(left,top,right,bottom)：设置在屏幕上的窗口大小，四个参数描述屏幕窗口四个角上的坐标（以像素表示）； 函数void glOrtho(left,right,bottom,top,near,far)：设置投影方式为正交投影（平行投影），其取景体积是一个各面均为矩形的六面体; 函数void gluPerspective(fovy,aspect,zNear,zFar)：设置投影方式为透视投影，其取景体积是一个截头锥体。 第三部分是OpenGL的主要部分，使用OpenGL的库函数构造几何物体对象的数学描述，包括点线面的位置和拓扑关系、几何变换、光照处理等等。 以上三个部分是OpenGL程序的基本框架，即使移植到使用MFC的Windows程序中，也是如此。只是由于Windows自身有一套显示方式，需要进行一些必要的改动以协调这两种不同显示方式。 （3）状态机制 OpenGL的工作方式是一种状态机制，它可以进行各种状态或模式设置，这些状态或模式在重新改变它们之前一直有效。例如，当前颜色就是一个状态变量，在这个状态改变之前，绘制的每个像素都将使用该颜色，直到当前颜色被设置为其它颜色为止。OpenGL中大量地使用了这种状态机制，如颜色模式、投影模式、单双显示缓存区的设置、背景色的设置、光源的位置和特性等等。许多状态变量可以通过glEnable()、glDisable()这两个函数来设置成有效或无效状态，如是否设置光照、是否进行深度检测等；在被设置成有效状态之后，绝大部分状态变量都有一个缺省值。通常情况下，可以用下列四个函数来获取某个状态变量的值：glGetBooleanv()、glGetDouble()、glGetFloatv()和glGetIntegerv()。究竟选择哪个函数应该根据所要获得的返回值的数据类型来决定。还有些状态变量有特殊的查询函数，如glGetLight*()、glGetError()和glPolygonStipple()等。另外，使用glPushAttrib()和glPopAttrib()函数，可以存储和恢复最近的状态变量的值。只要有可能，都应该使用这些函数，因为它们比其它查询函数的效率更高。 4．实验代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;GL/glut.h&gt; //需要正确安装GLUT，安装方法如预备知识中所述void myDisplay(void)&#123;glClearColor(0.0, 0.0, 0.0, 0.0);glClear(GL_COLOR_BUFFER_BIT);glColor3f (1.0f, 1.0f, 1.0f);glRectf(-0.5f, -0.5f, 0.5f, 0.5f);glBegin (GL_TRIANGLES);glColor3f (1.0f, 0.0f, 0.0f); glVertex2f (0.0f, 1.0f);glColor3f (0.0f, 1.0f, 0.0f); glVertex2f (0.8f, -0.5f);glColor3f (0.0f, 0.0f, 1.0f); glVertex2f (-0.8f, -0.5f);glEnd ();glPointSize(3);glBegin (GL_POINTS);glColor3f (1.0f, 0.0f, 0.0f); glVertex2f (-0.4f, -0.4f);glColor3f (0.0f, 1.0f, 0.0f); glVertex2f (0.0f, 0.0f);glColor3f (0.0f, 0.0f, 1.0f); glVertex2f (0.4f, 0.4f);glEnd ();glFlush();&#125;int main(int argc, char *argv[])&#123; glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE); glutInitWindowPosition(100, 100); glutInitWindowSize(400, 400); glutCreateWindow(&quot;Hello World!&quot;); glutDisplayFunc(&amp;myDisplay); glutMainLoop(); return 0;&#125; 程序说明：该程序的作用是在一个黑色的窗口中央画一个矩形、三角形和三个点，如图A.1(a)所示。下面对各行语句进行说明： 首先，需要包含头文件#include &lt;GL/glut.h&gt;，这是GLUT的头文件。本来OpenGL程序一般还要包含&lt;GL/gl.h&gt;和&lt;GL/glu.h&gt;，但GLUT的头文件中已经自动将这两个文件包含了，不必再次包含； 然后看main函数。int main(int argc, char *argv[])，这个是带命令行参数的main函数。注意main函数中的各语句，除了最后的return之外，其余全部以glut开头。这种以glut开头的函数都是GLUT工具包所提供的函数，下面对用到的几个函数进行介绍； 1）glutInit，对GLUT进行初始化，这个函数必须在其它的GLUT使用之前调用一次。其格式比较固定，一般都是glutInit(&amp;argc, argv)就行； 2) glutInitDisplayMode，设置显示方式，其中GLUT_RGB表示使用RGB颜色，与之对应的还有GLUT_INDEX（表示使用索引颜色）。GLUT_SINGLE表示使用单缓冲，与之对应的还有GLUT_DOUBLE（使用双缓冲）。更多信息，以后的实验教程会有讲解介绍； 3) glutInitWindowPosition，设置窗口在屏幕中的位置； 4) glutInitWindowSize，设置窗口的大小； 5) glutCreateWindow，根据前述设置的信息创建窗口。参数将被作为窗口的标题。注意：窗口被创建后，并不立即显示到屏幕上。需要调用glutMainLoop才能看到窗口； 6) glutDisplayFunc，设置一个函数，当需要进行画图时，这个函数就会被调用。（暂且这样理解）； 7) glutMainLoop，进行一个消息循环。（现在只需知道这个函数可以显示窗口，并且等待窗口关闭后才会返回。） 在glutDisplayFunc函数中，我们设置了“当需要画图时，请调用myDisplay函数”。于是myDisplay函数就用来画图。观察myDisplay中的三个函数调用，发现它们都以gl开头。这种以gl开头的函数都是OpenGL的标准函数，下面对用到的函数进行介绍： 1) glClearColor(0.0, 0.0, 0.0, 0.0) ：将清空颜色设为黑色（为什么会有四个参数？）； 2) glClear(GL_COLOR_BUFFER_BIT)：将窗口的背景设置为当前清空颜色； 3) glRectf，画一个矩形。四个参数分别表示了位于对角线上的两个点的横、纵坐标； 4) glFlush，保证前面的OpenGL命令立即执行（而不是让它们在缓冲区中等待）。 5．实验思考根据示范程序，能否在原有结果基础上添加三条直线组成三角形（如图A.1所示）？ 图A.1 加三角形后的效果]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
</search>
